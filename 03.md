# Étapes 

1. Je commence par le **pom.xml**.
2. Je vérifie le fichier **application.properties** :

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/microDemo1
spring.datasource.username=hrgres
spring.datasource.password=hrgres
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
```

3. **Retravailler le modèle Card** (voir **Annexe 1**).
4. **Retravailler le modèle Customer** (voir **Annexe 2**).
5. **Retravailler les contrôleurs** (voir **Annexe 3**).

> **Erreur** : Les contrôleurs référencent des services qui n'existent pas encore.

```bash
Changements principaux :
- Utilisation de `CardService` au lieu de manipuler directement une liste de cartes.
- Changement des types `int` en `Long` pour les IDs afin de correspondre au type généré par JPA.
- Suppression de la dépendance directe à `CustomerController`.
- Ajout d'une méthode pour obtenir les cartes d'un client spécifique.
- Utilisation cohérente de `ResponseEntity` pour toutes les réponses.
- Adaptation des méthodes pour utiliser les services JPA au lieu des opérations en mémoire.

Ce contrôleur est maintenant prêt à être utilisé avec JPA et un service correspondant, tout en conservant la documentation Swagger.
```

6. **Ajout du package service** et du package **exception** (voir **Annexe 4**).
7. **Ajout du package repository** et des classes (voir **Annexe 5**).
8. **Corrigez les erreurs dans le contrôleur** ou tout autre problème qui pourrait survenir (voir **Annexe 6** et **READMEplus.md**).

```bash
Points Clés :
- Passage de l'ID du client : Assurez-vous que l'ID du client est passé en tant que paramètre `@RequestParam` lors de l'ajout d'une nouvelle carte.
- Gestion des exceptions : Utilisation de `ResourceNotFoundException` pour gérer les cas où le client ou la carte n'existent pas.
- Utilisation cohérente de `ResponseEntity` pour toutes les réponses HTTP.

Ces modifications devraient résoudre l'erreur et permettre à votre contrôleur et service de fonctionner correctement ensemble.
```

# **Annexe 1 - Retravailler le modèle Card**

### Ancienne version :

```java
package com.example.demo.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Card {
    private int cardId;
    private int customerId;
    private String cardNumber;
    private String cardType;
    private int totalLimit;
    private int amountUsed;
    private int availableAmount;
    private String createDt;
}
```

### Nouvelle version :

Voici la classe **Card** réécrite pour respecter **Lombok** et **JPA** :

```java
package com.example.demo.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDate;

import jakarta.persistence.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "cards")
public class Card {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long cardId;

    @Column(nullable = false, unique = true)
    private String cardNumber;

    @Column(nullable = false)
    private String cardType;

    @Column(nullable = false)
    private int totalLimit;

    @Column(nullable = false)
    private int amountUsed;

    @Column(nullable = false)
    private int availableAmount;

    @Column(nullable = false)
    private LocalDate createDt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;
}
```

Changements et explications :
1. Ajout des annotations **JPA** : `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`, `@ManyToOne`, `@JoinColumn`.
2. Changement du type de `cardId` de `int` à `Long` pour correspondre au type généré par la stratégie d'identité.
3. Suppression de `customerId` et ajout d'une relation `@ManyToOne` avec **Customer**.
4. Ajout de contraintes `nullable = false` pour les champs obligatoires.
5. Ajout de `unique = true` pour **cardNumber** pour garantir son unicité.
6. Changement du type de `createDt` de `String` à `LocalDate` pour une meilleure gestion des dates.
7. Ajout de l'annotation **@Builder** de **Lombok** pour permettre la création d'instances avec un pattern builder.

# **Annexe 2 - Retravailler le modèle Customer**

### Ancienne version :

```java
package com.example.demo.model;

public class Customer {
    private int customerId;
    private String customerLastName;
    private String customerFirstName;

    public Customer() {}

    public Customer(int customerId, String customerLastName, String customerFirstName) {
        this.customerId = customerId;
        this.customerLastName = customerLastName;
        this.customerFirstName = customerFirstName;
    }

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getCustomerLastName() {
        return customerLastName;
    }

    public void setCustomerLastName(String customerLastName) {
        this.customerLastName = customerLastName;
    }

    public String getCustomerFirstName() {
        return customerFirstName;
    }

    public void setCustomerFirstName(String customerFirstName) {
        this.customerFirstName = customerFirstName;
    }
}
```

### Nouvelle version :

Voici la classe **Customer** retravaillée pour respecter les exigences de **JPA** et utiliser **Lombok** pour réduire le code :

```java
package com.example.demo.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "customers")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long customerId;

    @Column(name = "last_name", nullable = false)
    private String customerLastName;

    @Column(name = "first_name", nullable = false)
    private String customerFirstName;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<Card> cards = new ArrayList<>();

    // Méthode utilitaire pour ajouter une carte
    public void addCard(Card card) {
        cards.add(card);
        card.setCustomer(this);
    }

    // Méthode utilitaire pour supprimer une carte
    public void removeCard(Card card) {
        cards.remove(card);
        card.setCustomer(null);
    }
}
```

Changements et explications :
1. Ajout des annotations **JPA** : `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`, `@OneToMany`.
2. Utilisation des annotations **Lombok** : `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`, `@Builder`.
3. Changement du type de **customerId** de `int` à `Long`.
4. Ajout de la relation `@OneToMany` avec **Card**.
5. Ajout de méthodes utilitaires **addCard** et **removeCard** pour gérer la relation bidirectionnelle avec **Card**.

# **Annexe 3 - Retravailler les contrôleurs**

### Nouvelle version de **CardController** et **CustomerController** :

1. **CardController.java** :

```java
package com.example.demo.controller;

import com.example.demo.model.Card;
import com.example.demo.service.CardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/cards")
@Tag(name = "Card", description = "API pour la gestion des cartes bancaires")
public class CardController {

    private final CardService cardService;

    @Autowired
    public CardController(CardService cardService) {
        this.cardService = cardService;
    }

    @Operation(summary = "Ajouter une nouvelle carte", description = "Ajoute une nouvelle carte bancaire pour un client existant")
    @ApiResponse(responseCode = "200", description = "Carte ajoutée avec succès", content = @Content(schema = @Schema(implementation = Card.class)))
    @ApiResponse(responseCode = "400", description = "Données invalides ou client inexistant")
    @PostMapping
    public ResponseEntity<Card> addCard(@RequestBody Card card, @RequestParam Long customerId)

 {
        return ResponseEntity.ok(cardService.createCard(card, customerId));
    }

    @Operation(summary = "Obtenir toutes les cartes", description = "Récupère la liste de toutes les cartes bancaires")
    @ApiResponse(responseCode = "200", description = "Liste des cartes récupérée avec succès")
    @GetMapping
    public ResponseEntity<List<Card>> getAllCards() {
        return ResponseEntity.ok(cardService.getAllCards());
    }

    @Operation(summary = "Obtenir une carte par ID", description = "Récupère les détails d'une carte bancaire spécifique")
    @ApiResponse(responseCode = "200", description = "Carte trouvée", content = @Content(schema = @Schema(implementation = Card.class)))
    @ApiResponse(responseCode = "404", description = "Carte non trouvée")
    @GetMapping("/{id}")
    public ResponseEntity<Card> getCardById(@Parameter(description = "ID de la carte") @PathVariable Long id) {
        return cardService.getCardById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @Operation(summary = "Mettre à jour une carte", description = "Met à jour les détails d'une carte bancaire existante")
    @ApiResponse(responseCode = "200", description = "Carte mise à jour avec succès", content = @Content(schema = @Schema(implementation = Card.class)))
    @ApiResponse(responseCode = "404", description = "Carte non trouvée")
    @PutMapping("/{id}")
    public ResponseEntity<Card> updateCard(@Parameter(description = "ID de la carte") @PathVariable Long id, @RequestBody Card updatedCard) {
        return ResponseEntity.ok(cardService.updateCard(id, updatedCard));
    }

    @Operation(summary = "Supprimer une carte", description = "Supprime une carte bancaire spécifique")
    @ApiResponse(responseCode = "200", description = "Carte supprimée avec succès")
    @ApiResponse(responseCode = "404", description = "Carte non trouvée")
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCard(@Parameter(description = "ID de la carte") @PathVariable Long id) {
        cardService.deleteCard(id);
        return ResponseEntity.ok().build();
    }
}
```

2. **CustomerController.java** :

```java
package com.example.demo.controller;

import com.example.demo.model.Customer;
import com.example.demo.service.CustomerService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/customers")
@Tag(name = "Customer", description = "API pour la gestion des clients")
public class CustomerController {

    private final CustomerService customerService;

    @Autowired
    public CustomerController(CustomerService customerService) {
        this.customerService = customerService;
    }

    @Operation(summary = "Ajouter un nouveau client", description = "Ajoute un nouveau client dans le système")
    @ApiResponse(responseCode = "200", description = "Client ajouté avec succès", content = @Content(schema = @Schema(implementation = Customer.class)))
    @ApiResponse(responseCode = "400", description = "Un client avec cet ID existe déjà")
    @PostMapping
    public ResponseEntity<Customer> addCustomer(@RequestBody Customer customer) {
        return ResponseEntity.ok(customerService.createCustomer(customer));
    }

    @Operation(summary = "Obtenir tous les clients", description = "Récupère la liste de tous les clients")
    @ApiResponse(responseCode = "200", description = "Liste des clients récupérée avec succès")
    @GetMapping
    public ResponseEntity<List<Customer>> getAllCustomers() {
        return ResponseEntity.ok(customerService.getAllCustomers());
    }

    @Operation(summary = "Obtenir un client par ID", description = "Récupère les détails d'un client spécifique")
    @ApiResponse(responseCode = "200", description = "Client trouvé", content = @Content(schema = @Schema(implementation = Customer.class)))
    @ApiResponse(responseCode = "404", description = "Client non trouvé")
    @GetMapping("/{id}")
    public ResponseEntity<Customer> getCustomerById(@Parameter(description = "ID du client") @PathVariable Long id) {
        return customerService.getCustomerById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @Operation(summary = "Mettre à jour un client", description = "Met à jour les détails d'un client existant")
    @ApiResponse(responseCode = "200", description = "Client mis à jour avec succès", content = @Content(schema = @Schema(implementation = Customer.class)))
    @ApiResponse(responseCode = "404", description = "Client non trouvé")
    @PutMapping("/{id}")
    public ResponseEntity<Customer> updateCustomer(@Parameter(description = "ID du client") @PathVariable Long id, @RequestBody Customer updatedCustomer) {
        return ResponseEntity.ok(customerService.updateCustomer(id, updatedCustomer));
    }

    @Operation(summary = "Supprimer un client", description = "Supprime un client spécifique s'il n'a pas de cartes associées")
    @ApiResponse(responseCode = "200", description = "Client supprimé avec succès")
    @ApiResponse(responseCode = "400", description = "Impossible de supprimer le client car il possède des cartes")
    @ApiResponse(responseCode = "404", description = "Client non trouvé")
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCustomer(@Parameter(description = "ID du client") @PathVariable Long id) {
        customerService.deleteCustomer(id);
        return ResponseEntity.ok().build();
    }
}
```

