# Table des Matières

1. [Structure des noms de méthodes](#structure-des-noms-de-méthodes)  
2. [Mots-clés supportés par Spring Data JPA](#mots-clés-supportés-par-spring-data-jpa)  
3. [Combinaison de mots-clés](#combinaison-de-mots-clés)  
4. [Traverser les relations entre entités](#traverser-les-relations-entre-entités)  
5. [Requêtes personnalisées avec `@Query`](#requêtes-personnalisées-avec-query)  
6. [Conseils pratiques pour l'utilisation des conventions de nommage](#conseils-pratiques-pour-lutilisation-des-conventions-de-nommage)  
7. [Cas pratique : gestion des entités `Customer` et `Order`](#cas-pratique--gestion-des-entités-customer-et-order)  
8. [Conclusion](#conclusion)  
9. [Annexe 1 - Méthodes personnalisées dans Spring Data JPA](#annexe-1---méthodes-personnalisées-dans-spring-data-jpa)  
10. [Exercice 1 - Application JPA avec Customer et Card](#exercice-1---application-jpa-avec-customer-et-card)  
11. [Exercice 2 - Diagramme de la base de données avec Airport, Flight et Passenger](#exercice-2---diagramme-de-la-base-de-données-avec-airport-flight-et-passenger)  
12. [Exercice 3 - Jointures dans Spring Data JPA](#exercice-3---jointures-dans-spring-data-jpa)

---


### 1. <a id="structure-des-noms-de-méthodes"></a>Structure des noms de méthodes
[Retour à la table des matières](#table-des-matières)

L'une des principales forces de Spring Data JPA est sa capacité à générer des requêtes dynamiques en analysant simplement le nom des méthodes définies dans les interfaces `Repository`. Cela permet aux développeurs d'écrire des méthodes expressives, sans avoir à manipuler directement du SQL ou JPQL. La structure typique des noms de méthodes suit un modèle prédictif qui combine attributs et opérations.

#### Modèle général de nommage :

```
findBy[Attribut][Opération][AutreAttribut][Opération]...
```

- **`findBy`** : Le préfixe `findBy` indique que vous souhaitez récupérer une ou plusieurs entités en fonction d'un ou plusieurs critères.
- **`Attribut`** : Correspond au nom de l'attribut de l'entité sur lequel la recherche est effectuée. Par exemple, si vous avez une entité `User` avec un champ `lastname`, vous pouvez écrire `findByLastname`.
- **`Opération`** : Indique l'opération à effectuer sur l'attribut (e.g. `LessThan`, `GreaterThan`, `IsNull`), permettant des recherches plus complexes.

#### Exemples de méthodes dérivées :
1. **`findByLastname`** : Cette méthode génère une requête pour retrouver tous les enregistrements où le champ `lastname` correspond à la valeur fournie.
   - JPQL : `SELECT u FROM User u WHERE u.lastname = ?1`

2. **`findByFirstnameAndLastname`** : Recherche d'une entité avec des critères multiples. Ici, la recherche se fait à la fois par prénom (`firstname`) et nom de famille (`lastname`).
   - JPQL : `SELECT u FROM User u WHERE u.firstname = ?1 AND u.lastname = ?2`

3. **`findByAgeLessThanAndFirstnameStartingWith`** : Ici, la méthode combine plusieurs opérations sur différents champs. Elle récupère les entités où l'âge est inférieur à une certaine valeur et où le prénom commence par une chaîne de caractères spécifique.
   - JPQL : `SELECT u FROM User u WHERE u.age < ?1 AND u.firstname LIKE ?2%`

#### Autres préfixes courants :

- **`countBy`** : Retourne le nombre d'entités correspondant aux critères donnés.
  - Ex. : `countByLastname(String lastname)`
- **`existsBy`** : Vérifie si au moins une entité correspondant aux critères existe.
  - Ex. : `existsByLastname(String lastname)`

---

### 2. <a id="mots-clés-supportés-par-spring-data-jpa"></a>Mots-clés supportés par Spring Data JPA
[Retour à la table des matières](#table-des-matières)

Spring Data JPA offre un large éventail de mots-clés qui permettent de spécifier différentes conditions de recherche. Ces mots-clés sont utilisés pour affiner les requêtes sans écrire de code SQL explicite.

Voici quelques-uns des mots-clés les plus courants, avec des exemples de requêtes générées :

| **Mot-clé**          | **Exemple**                        | **JPQL généré**                              |
|----------------------|------------------------------------|----------------------------------------------|
| `And`                | `findByLastnameAndFirstname`       | `... where x.lastname = ?1 and x.firstname = ?2` |
| `Or`                 | `findByLastnameOrFirstname`        | `... where x.lastname = ?1 or x.firstname = ?2`  |
| `Is`, `Equals`       | `findByFirstnameEquals`            | `... where x.firstname = ?1` |
| `Between`            | `findByAgeBetween`                 | `... where x.age between ?1 and ?2`          |
| `LessThan`           | `findByAgeLessThan`                | `... where x.age < ?1`                       |
| `GreaterThan`        | `findByAgeGreaterThan`             | `... where x.age > ?1`                       |
| `IsNull`             | `findByAgeIsNull`                  | `... where x.age is null`                    |
| `Like`               | `findByFirstnameLike`              | `... where x.firstname like ?1`              |
| `In`                 | `findByAgeIn(Collection<Integer> ages)` | `... where x.age in ?1`                    |
| `NotIn`              | `findByAgeNotIn(Collection<Integer> ages)` | `... where x.age not in ?1`              |
| `True`               | `findByActiveTrue()`               | `... where x.active = true`                  |
| `False`              | `findByActiveFalse()`              | `... where x.active = false`                 |
| `IgnoreCase`         | `findByLastnameIgnoreCase`         | `... where lower(x.lastname) = lower(?1)`    |

#### Points clés :
- **Opérateurs relationnels** : `GreaterThan`, `LessThan`, `Between`, `IsNull`, etc., permettent d'appliquer des conditions numériques ou de date.
- **Opérateurs de chaîne** : `Like`, `StartingWith`, `EndingWith`, etc., permettent de manipuler les chaînes de caractères dans les requêtes.
- **Gestion de la casse** : `IgnoreCase` permet d'ignorer la casse des champs de type chaîne.

---

### 3. <a id="combinaison-de-mots-clés"></a>Combinaison de mots-clés
[Retour à la table des matières](#table-des-matières)

Il est possible de combiner plusieurs mots-clés dans une méthode pour obtenir des requêtes plus complexes, à la fois sur plusieurs attributs et avec différentes opérations. Cela permet d'ajuster précisément les conditions de recherche.

#### Exemples :

1. **`findByLastnameAndFirstnameAllIgnoreCase`**
   - Cette méthode recherche les entités où le nom de famille et le prénom correspondent, en ignorant la casse. Elle combine les mots-clés `And` et `IgnoreCase`.
   - JPQL généré : `SELECT u FROM User u WHERE lower(u.lastname) = lower(?1) AND lower(u.firstname) = lower(?2)`

2. **`findByAgeLessThanAndLastnameStartingWith`**
   - Ici, la recherche se fait en deux étapes : la première vérifie si l'âge est inférieur à une valeur donnée, et la seconde s'assure que le nom de famille commence par une chaîne spécifique.
   - JPQL généré : `SELECT u FROM User u WHERE u.age < ?1 AND u.lastname LIKE ?2%`

3. **`findByCreateDateBetweenAndStatusIn`**
   - Recherche des entités dont la date de création est comprise entre deux valeurs, et dont le statut appartient à une liste prédéfinie.
   - JPQL généré : `SELECT u FROM Entity u WHERE u.createDate BETWEEN ?1 AND ?2 AND u.status IN ?3`

---

### 4. <a id="traverser-les-relations-entre-entités"></a>Traverser les relations entre entités
[Retour à la table des matières](#table-des-matières)

Dans Spring Data JPA, il est également possible de traverser les relations entre entités pour interroger des tables liées. Ceci est particulièrement utile pour les relations **OneToMany** et **ManyToOne**, où les entités sont liées entre elles.

#### Exemple :

Supposons que vous ayez deux entités : `Product` et `Category`. Un produit peut appartenir à une ou plusieurs catégories.

```java
@Entity
public class Product {
    @Id
    private Long id;

    @ManyToOne
    private Category category;
}
```

Vous pouvez écrire une méthode dans le repository qui traverse la relation entre `Product` et `Category` :

```java
List<Product> findByCategoryName(String categoryName);
```

- **Explication** : Spring Data JPA comprendra qu'il doit utiliser la relation entre `Product` et `Category` pour générer une requête qui recherche des produits appartenant à une catégorie dont le nom est spécifié.
- **JPQL généré** : `SELECT p FROM Product p JOIN p.category c WHERE c.name = ?1`

---

### 5. <a id="requêtes-personnalisées-avec-query"></a>Requêtes personnalisées avec `@Query`
[Retour à la table des matières](#table-des-matières)

Bien que les méthodes dérivées soient très puissantes, elles ne couvrent pas tous les cas d'utilisation, surtout lorsque vous devez exécuter des requêtes plus complexes. Dans ces cas, vous pouvez utiliser l'annotation `@Query` pour définir des requêtes JPQL personnalisées.

#### Exemple de JPQL :

```java
@Query("SELECT p FROM Product p WHERE p.name = ?1")
List<Product> findByName(String name);
```

- **Explication** : Ici, vous spécifiez explicitement une requête JPQL qui sélectionne tous les produits dont le nom correspond à la valeur fournie.
- **JPQL généré** : `SELECT p FROM Product p WHERE p.name = ?1`

#### Exemple de SQL natif :

Si vous avez besoin d'utiliser du SQL natif, vous pouvez le faire en définissant la propriété `nativeQuery = true`.

```

java
@Query(value = "SELECT * FROM product WHERE price = :price", nativeQuery = true)
List<Product> findByPriceNative(@Param("price") BigDecimal price);
```

- **Explication** : Ici, vous utilisez une requête SQL classique, plutôt que JPQL, pour interroger la base de données directement.

---

### 6. <a id="conseils-pratiques-pour-lutilisation-des-conventions-de-nommage"></a>Conseils pratiques pour l'utilisation des conventions de nommage
[Retour à la table des matières](#table-des-matières)

#### 1. **Simplicité avant tout**
   - Utilisez les conventions de nommage pour des cas simples. Par exemple, au lieu de créer une requête personnalisée pour une recherche par nom, utilisez simplement `findByLastname`.

#### 2. **Complexité et flexibilité**
   - Si vos besoins deviennent plus complexes, commencez par utiliser les méthodes dérivées. Si cela ne suffit pas, utilisez des requêtes JPQL via l'annotation `@Query`.

#### 3. **Performance**
   - Évitez d'utiliser des méthodes dérivées pour des requêtes très complexes qui nécessitent de multiples jointures ou opérations coûteuses. Dans ces cas, une requête SQL ou JPQL bien optimisée sera plus performante.

#### 4. **Cohérence**
   - Maintenez des noms de méthodes cohérents pour garantir la lisibilité du code. Préférez des noms explicites et descriptifs comme `findByFirstnameAndLastname` à des noms courts mais peu clairs.















# ANENXE 1



ajoure ca en annexe # Question: Quand et pourquoi écrire une méthode personnalisée comme findByCustomerId dans un Repository Spring Data JPA ?

# 1. Introduction à Spring Data JPA et les Repositories
Spring Data JPA est un framework qui facilite l'accès aux bases de données dans les applications Java, en s'appuyant sur JPA (Java Persistence API). L'un des avantages de Spring Data JPA est qu'il fournit des interfaces prêtes à l'emploi, comme CrudRepository, qui offrent un ensemble de méthodes CRUD (Create, Read, Update, Delete) sans que vous ayez besoin de les implémenter manuellement.

# 2. Les Méthodes par Défaut de CrudRepository
Lorsque vous étendez CrudRepository, vous bénéficiez d'un ensemble de méthodes CRUD prédéfinies, telles que :
- save(S entity) : Pour sauvegarder ou mettre à jour une entité.
- findById(ID id) : Pour récupérer une entité par son ID.
- findAll() : Pour récupérer toutes les entités.
- deleteById(ID id) : Pour supprimer une entité par son ID.
- Et plusieurs autres...

Ces méthodes couvrent les opérations de base que vous effectuerez fréquemment. Cependant, dans certaines situations, vous aurez besoin d'effectuer des requêtes plus spécifiques qui ne sont pas couvertes par les méthodes standards de CrudRepository.

## Exercice : 

### 1️⃣ Cloner le projet
bash
git clone https://github.com/hrhouma1/accounts-v1.git


### 2️⃣ Accéder au répertoire du projet
bash
cd accounts-v1


### 3️⃣ Ouvrir le projet dans votre éditeur de code (par exemple, Visual Studio Code) et observez la classe AccountsRepository dans le dossier Repository

bash
code .


bash
package com.eazybytes.accounts.repository;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import com.eazybytes.accounts.model.Accounts;

@Repository
public interface AccountsRepository extends CrudRepository<Accounts, Long> {

	Accounts findByCustomerId(int customerId);

}




# Question:

Pourquoi le repository contient-il uniquement la méthode findByCustomerId ? Pourquoi les autres méthodes comme save, delete, ou findAll ne sont-elles pas visibles dans ce repository ? Expliquez la raison de leur absence apparente et comment elles sont réellement accessibles.

# 3. Quand écrire une méthode personnalisée comme findByCustomerId ?
Vous devez écrire une méthode personnalisée lorsque :
- **Vous avez besoin de requêtes spécifiques** : Lorsque vous devez interroger la base de données en fonction d'une ou plusieurs colonnes spécifiques qui ne sont pas l'ID primaire. Par exemple, rechercher un compte en fonction de l'ID du client plutôt qu'en utilisant l'ID du compte.
- **Vous souhaitez simplifier l'accès aux données** : Au lieu d'écrire une requête SQL personnalisée à chaque fois, vous pouvez créer une méthode dans le Repository pour rendre le code plus propre et réutilisable.
- **Vous avez besoin d'opérations complexes** : Parfois, vous devez interroger plusieurs colonnes ou appliquer des conditions spécifiques. Dans ce cas, une méthode personnalisée peut être plus appropriée.

# 4. Comment écrire une méthode personnalisée ?
Spring Data JPA permet de définir des méthodes personnalisées en se basant sur les conventions de nommage. Par exemple, pour créer une méthode qui recherche un compte par customerId, vous pouvez simplement déclarer une méthode comme suit :

java
Accounts findByCustomerId(int customerId);


Spring Data JPA se base sur le nom de la méthode pour générer automatiquement l'implémentation de la requête SQL correspondante. Dans cet exemple :
- findBy : Indique que vous voulez effectuer une recherche.
- CustomerId : Spécifie le champ sur lequel la recherche doit être effectuée.

Spring Data JPA comprend ces conventions et génère une requête pour récupérer les comptes où customerId correspond à la valeur fournie.

# 5. Exemples de Méthodes Personnalisées
Voici quelques exemples de méthodes personnalisées que vous pourriez vouloir écrire dans un Repository :

- **Recherche par plusieurs champs** : Si vous voulez rechercher des comptes par customerId et accountType, vous pouvez déclarer :
  
java
  Accounts findByCustomerIdAndAccountType(int customerId, String accountType);


- **Recherche par une partie d'un champ** : Si vous voulez rechercher des comptes où l'adresse de la branche (branchAddress) contient une chaîne de caractères spécifique, vous pouvez déclarer :
  
java
  List<Accounts> findByBranchAddressContaining(String addressFragment);


- **Recherche en utilisant une plage de valeurs** : Si vous voulez rechercher des comptes créés après une certaine date, vous pouvez déclarer :
  
java
  List<Accounts> findByCreateDtAfter(LocalDate date);


# 6. Avantages des Méthodes Personnalisées
- **Lisibilité** : Le code devient plus lisible, car vous pouvez nommer vos méthodes de manière descriptive.
- **Réutilisabilité** : Une fois définies, ces méthodes peuvent être réutilisées partout dans votre application.
- **Maintenance** : En utilisant des méthodes personnalisées, vous évitez d'avoir à écrire des requêtes SQL complexes partout dans votre code, ce qui facilite la maintenance.

# 7. Quand ne pas écrire de Méthodes Personnalisées
- **Lorsque les méthodes de CrudRepository sont suffisantes** : Si les méthodes standards couvrent vos besoins (par exemple, findById ou findAll), il n'est pas nécessaire de créer des méthodes supplémentaires.
- **Lorsque vous avez besoin de requêtes très complexes** : Dans certains cas, les méthodes personnalisées basées sur des conventions de nommage peuvent ne pas être suffisantes pour exprimer des requêtes SQL très complexes. Dans ces situations, vous devrez peut-être utiliser des requêtes JPQL ou Criteria API.

# 8. Conclusion
Écrire des méthodes personnalisées dans un Repository Spring Data JPA est une manière puissante de simplifier l'accès aux données et de rendre votre code plus lisible et maintenable. Vous devriez envisager d'écrire de telles méthodes chaque fois que vous avez besoin d'une requête spécifique qui n'est pas couverte par les méthodes CRUD par défaut. En comprenant les conventions de nommage, vous pouvez facilement créer des méthodes adaptées à vos besoins sans écrire de requêtes SQL complexes.

En adoptant cette pratique, vous contribuerez à une meilleure organisation et à une meilleure structure de votre code, facilitant ainsi la maintenance et l'évolution de votre application.









# Exercice 1 et 2 


ajoute exercice 1 et exercice 2 en anenxe exercice 1 # Application JPA 

- Cet exercice fournit une progression naturelle de méthodes simples (findBy) vers des requêtes plus complexes nécessitant une réflexion plus approfondie et l'utilisation de jointures et d'agrégations.
- Je vous propose une série de 30 requêtes SQL, classées de la plus simple à la plus complexe, basées sur le diagramme de votre base de données Customer et Card.
- Votre mission est de compléter les noms des méthodes JPA dans la colonne dédiée :



| **Niveau**   | **Requête SQL**                                                                                                                                  | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | SELECT * FROM Customer;                                                                                                                        | Récupérer tous les clients.                                           |                                         |
| **Facile**   | SELECT * FROM Card;                                                                                                                            | Récupérer toutes les cartes.                                          |                                         |
| **Facile**   | SELECT * FROM Customer WHERE customerId = 1;                                                                                                   | Récupérer un client par son ID.                                       |                                         |
| **Facile**   | SELECT * FROM Card WHERE cardId = 2;                                                                                                           | Récupérer une carte par son ID.                                       |                                         |
| **Facile**   | SELECT * FROM Customer WHERE customerFirstName = 'John';                                                                                       | Rechercher un client par son prénom.                                  |                                         |
| **Facile**   | SELECT * FROM Customer WHERE customerLastName = 'Doe';                                                                                         | Rechercher un client par son nom de famille.                          |                                         |
| **Facile**   | SELECT * FROM Card WHERE customerId = 1;                                                                                                       | Rechercher toutes les cartes d'un client spécifique par son customerId. |                                         |
| **Facile**   | SELECT * FROM Card WHERE cardNumber = '1234567890';                                                                                            | Rechercher une carte par son numéro.                                  |                                         |
| **Facile**   | SELECT * FROM Card WHERE cardType = 'Gold';                                                                                                    | Rechercher toutes les cartes de type "Gold".                          |                                         |
| **Facile**   | SELECT * FROM Customer WHERE customerFirstName = 'John' AND customerLastName = 'Doe';                                                          | Rechercher un client par son prénom et son nom de famille.            |                                         |
| **Facile**   | SELECT * FROM Customer WHERE customerFirstName LIKE 'J%';                                                                                      | Rechercher les clients dont le prénom commence par 'J'.               |                                         |
| **Facile**   | SELECT * FROM Card WHERE totalLimit = 10000;                                                                                                   | Rechercher les cartes avec une limite totale de 10000.                |                                         |
| **Moyen**    | SELECT * FROM Card WHERE availableAmount > 500;                                                                                                | Rechercher les cartes avec un montant disponible supérieur à 500.     |                                         |
| **Moyen**    | SELECT * FROM Card WHERE amountUsed < 2000;                                                                                                    | Rechercher les cartes avec un montant utilisé inférieur à 2000.       |                                         |
| **Moyen**    | SELECT * FROM Card WHERE createDt > '2024-01-01';                                                                                              | Rechercher les cartes créées après une date spécifique.               |                                         |
| **Moyen**    | SELECT * FROM Customer WHERE customerLastName = 'Smith' OR customerLastName = 'Doe';                                                           | Rechercher les clients avec les noms de famille 'Smith' ou 'Doe'.     |                                         |
| **Moyen**    | SELECT * FROM Card WHERE totalLimit > 3000 AND totalLimit < 7000;                                                                              | Rechercher les cartes avec une limite totale comprise entre 3000 et 7000. |                                         |
| **Moyen**    | SELECT * FROM Card WHERE cardType = 'Gold' AND totalLimit > 5000;                                                                              | Rechercher les cartes de type "Gold" avec une limite totale supérieure à 5000. |                                         |
| **Moyen**    | SELECT * FROM Customer WHERE customerFirstName IN ('John', 'Jane', 'Jim');                                                                     | Rechercher les clients avec une liste de prénoms spécifiques.         |                                         |
| **Moyen**    | SELECT COUNT(*) FROM Card WHERE cardType = 'Platinum';                                                                                         | Compter le nombre de cartes de type "Platinum".                      |                                         |
| **Moyen**    | SELECT AVG(totalLimit) FROM Card WHERE cardType = 'Gold';                                                                                      | Calculer la limite totale moyenne des cartes de type "Gold".          |                                         |
| **Difficile**| SELECT * FROM Customer c JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardType = 'Gold';                                               | Rechercher les clients ayant une carte de type "Gold".                |                                         |
| **Difficile**| SELECT * FROM Customer WHERE EXISTS (SELECT 1 FROM Card WHERE customerId = Customer.customerId AND cardType = 'Platinum');                     | Rechercher les clients ayant au moins une carte de type "Platinum".   |                                         |
| **Difficile**| SELECT * FROM Card WHERE amountUsed > 1000 AND availableAmount < 500;                                                                          | Rechercher les cartes avec un montant utilisé supérieur à 1000 et un montant disponible inférieur à 500. |                                         |
| **Difficile**| SELECT c.* FROM Customer c LEFT JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardId IS NULL;                                           | Rechercher les clients n'ayant aucune carte associée.                 |                                         |
| **Difficile**| SELECT * FROM Card WHERE createDt BETWEEN '2024-01-01' AND '2024-12-31';                                                                       | Rechercher les cartes créées dans l'année 2024.                       |                                         |
| **Difficile**| SELECT * FROM Card WHERE availableAmount > 1000 ORDER BY availableAmount DESC;                                                                 | Rechercher les cartes avec un montant disponible supérieur à 1000, triées par montant disponible décroissant. |                                         |
| **Difficile**| SELECT * FROM Customer c JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardType = 'Gold' AND ca.totalLimit > 5000 ORDER BY c.customerLastName; | Rechercher les clients ayant une carte "Gold" avec une limite totale supérieure à 5000, triés par nom de famille. |                                         |
| **Difficile**| SELECT SUM(availableAmount) FROM Card WHERE customerId = 1;                                                                                    | Calculer le montant disponible total des cartes d'un client spécifique. |                                         |
| **Difficile**| SELECT * FROM Card WHERE totalLimit > 5000 AND amountUsed BETWEEN 1000 AND 2000;                                                               | Rechercher les cartes avec une limite totale supérieure à 5000 et un montant utilisé compris entre 1000 et 2000. |                                         |

### Instructions pour les étudiants :

- Complétez la colonne **Nom de la méthode JPA** en dérivant les méthodes à partir des requêtes SQL.
- Respectez la syntaxe des méthodes JPA avec des préfixes comme findBy, countBy, sumBy, et utilisez les bons opérateurs (And, Or, GreaterThan, etc.).







--------------------------------
# 1 - Rappel des deux classes **Customer** et **Card** avec les relations de clé primaire (PK) et clé étrangère (FK) :
--------------------------------

## Relation entre un client et ses cartes, où un client peut avoir plusieurs cartes.

+--------------------------+             +--------------------------+
|        Customer           |             |          Card             |
+--------------------------+             +--------------------------+
| - customerId (PK)         | <-----------| - cardId (PK)             |
| - customerFirstName       |             | - customerId (FK)         |
| - customerLastName        |             | - cardNumber              |
+--------------------------+             | - cardType                |
                                          | - totalLimit              |
                                          | - amountUsed              |
                                          | - availableAmount         |
                                          | - createDt                |
                                          +--------------------------+


- **Customer** : La classe Customer contient customerId comme clé primaire (PK).
- **Card** : La classe Card contient cardId comme clé primaire (PK) et customerId comme clé étrangère (FK) qui fait référence à Customer.


----------------------




| **Niveau**   | **Requête SQL**                                                                                                                                  | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | SELECT * FROM Customer;                                                                                                                        | Récupérer tous les clients.                                           | findAll()                             |
| **Facile**   | SELECT * FROM Card;                                                                                                                            | Récupérer toutes les cartes.                                          | findAll()                             |
| **Facile**   | SELECT * FROM Customer WHERE customerId = 1;                                                                                                   | Récupérer un client par son ID.                                       | findByCustomerId(Long customerId)     |
| **Facile**   | SELECT * FROM Card WHERE cardId = 2;                                                                                                           | Récupérer une carte par son ID.                                       | findByCardId(Long cardId)             |
| **Facile**   | SELECT * FROM Customer WHERE customerFirstName = 'John';                                                                                       | Rechercher un client par son prénom.                                  | findByCustomerFirstName(String firstName) |
| **Facile**   | SELECT * FROM Customer WHERE customerLastName = 'Doe';                                                                                         | Rechercher un client par son nom de famille.                          | findByCustomerLastName(String lastName) |
| **Facile**   | SELECT * FROM Card WHERE customerId = 1;                                                                                                       | Rechercher toutes les cartes d'un client spécifique par son customerId. | findByCustomerCustomerId(Long customerId) |
| **Facile**   | SELECT * FROM Card WHERE cardNumber = '1234567890';                                                                                            | Rechercher une carte par son numéro.                                  | findByCardNumber(String cardNumber)   |
| **Facile**   | SELECT * FROM Card WHERE cardType = 'Gold';                                                                                                    | Rechercher toutes les cartes de type "Gold".                          | findByCardType(String cardType)       |
| **Facile**   | SELECT * FROM Customer WHERE customerFirstName = 'John' AND customerLastName = 'Doe';                                                          | Rechercher un client par son prénom et son nom de famille.            | findByCustomerFirstNameAndCustomerLastName(String firstName, String lastName) |
| **Facile**   | SELECT * FROM Customer WHERE customerFirstName LIKE 'J%';                                                                                      | Rechercher les clients dont le prénom commence par 'J'.               | findByCustomerFirstNameStartingWith(String prefix) |
| **Facile**   | SELECT * FROM Card WHERE totalLimit = 10000;                                                                                                   | Rechercher les cartes avec une limite totale de 10000.                | findByTotalLimit(Double totalLimit)   |
| **Moyen**    | SELECT * FROM Card WHERE availableAmount > 500;                                                                                                | Rechercher les cartes avec un montant disponible supérieur à 500.     | findByAvailableAmountGreaterThan(Double amount) |
| **Moyen**    | SELECT * FROM Card WHERE amountUsed < 2000;                                                                                                    | Rechercher les cartes avec un montant utilisé inférieur à 2000.       | findByAmountUsedLessThan(Double amount) |
| **Moyen**    | SELECT * FROM Card WHERE createDt > '2024-01-01';                                                                                              | Rechercher les cartes créées après une date spécifique.               | findByCreateDtAfter(LocalDate date)   |
| **Moyen**    | SELECT * FROM Customer WHERE customerLastName = 'Smith' OR customerLastName = 'Doe';                                                           | Rechercher les clients avec les noms de famille 'Smith' ou 'Doe'.     | findByCustomerLastNameIn(List<String> lastNames) |
| **Moyen**    | SELECT * FROM Card WHERE totalLimit > 3000 AND totalLimit < 7000;                                                                              | Rechercher les cartes avec une limite totale comprise entre 3000 et 7000. | findByTotalLimitBetween(Double min, Double max) |
| **Moyen**    | SELECT * FROM Card WHERE cardType = 'Gold' AND totalLimit > 5000;                                                                              | Rechercher les cartes de type "Gold" avec une limite totale supérieure à 5000. | findByCardTypeAndTotalLimitGreaterThan(String cardType, Double totalLimit) |
| **Moyen**    | SELECT * FROM Customer WHERE customerFirstName IN ('John', 'Jane', 'Jim');                                                                     | Rechercher les clients avec une liste de prénoms spécifiques.         | findByCustomerFirstNameIn(List<String> firstNames) |
| **Moyen**    | SELECT COUNT(*) FROM Card WHERE cardType = 'Platinum';                                                                                         | Compter le nombre de cartes de type "Platinum".                      | countByCardType(String cardType)      |
| **Moyen**    | SELECT AVG(totalLimit) FROM Card WHERE cardType = 'Gold';                                                                                      | Calculer la limite totale moyenne des cartes de type "Gold".          | findAvgTotalLimitByCardType(String cardType) |
| **Difficile**| SELECT * FROM Customer c JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardType = 'Gold';                                               | Rechercher les clients ayant une carte de type "Gold".                | findByCardsCardType(String cardType)  |
| **Difficile**| SELECT * FROM Customer WHERE EXISTS (SELECT 1 FROM Card WHERE customerId = Customer.customerId AND cardType = 'Platinum');                     | Rechercher les clients ayant au moins une carte de type "Platinum".   | findByCardsCardTypeExists(String cardType) |
| **Difficile**| SELECT * FROM Card WHERE amountUsed > 1000 AND availableAmount < 500;                                                                          | Rechercher les cartes avec un montant utilisé supérieur à 1000 et un montant disponible inférieur à 500. | findByAmountUsedGreaterThanAndAvailableAmountLessThan(Double used, Double available) |
| **Difficile**| SELECT c.* FROM Customer c LEFT JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardId IS NULL;                                           | Rechercher les clients n'ayant aucune carte associée.                 | findByCardsIsNull()                   |
| **Difficile**| SELECT * FROM Card WHERE createDt BETWEEN '2024-01-01' AND '2024-12-31';                                                                       | Rechercher les cartes créées dans l'année 2024.                       | findByCreateDtBetween(LocalDate start, LocalDate end) |
| **Difficile**| SELECT * FROM Card WHERE availableAmount > 1000 ORDER BY availableAmount DESC;                                                                 | Rechercher les cartes avec un montant disponible supérieur à 1000, triées par montant disponible décroissant. | findByAvailableAmountGreaterThanOrderByAvailableAmountDesc(Double amount) |
| **Difficile**| SELECT * FROM Customer c JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardType = 'Gold' AND ca.totalLimit > 5000 ORDER BY c.customerLastName; | Rechercher les clients ayant une carte "Gold" avec une limite totale supérieure à 5000, triés par nom de famille. | findByCardsCardTypeAndTotalLimitGreaterThanOrderByCustomerLastName(String cardType, Double limit) |
| **Difficile**| SELECT SUM(availableAmount) FROM Card WHERE customerId = 1;                                                                                    | Calculer le montant disponible total des cartes d'un client spécifique. | sumByCustomerId(Long customerId)      |
| **Difficile**| SELECT * FROM Card WHERE totalLimit > 5000 AND amountUsed BETWEEN 1000 AND 2000;                                                               | Rechercher les cartes avec une limite totale supérieure à 5000 et un montant utilisé compris entre 1000 et 2000. | findByTotalLimitGreaterThanAndAmountUsedBetween(Double limit, Double minAmount, Double maxAmount) |

Ces méthodes JPA sont dérivées des requêtes SQL selon la convention de nommage de Spring Data JPA. exercice 2  # Diagramme de la base de données (Relation entre les entités **Airport**, **Flight**, et **Passenger**)

+-----------------------------+             +-----------------------------+
|           Airport            |             |           Flight            |
+-----------------------------+             +-----------------------------+
| - airportId (PK)             | <-----------| - flightId (PK)             |
| - airportName                |             | - airportId (FK)            |
| - location                   |             | - destination               |
|                               |             | - departureTime             |
+-----------------------------+             +-----------------------------+
                                             |
                                             |
                                             v
                                +-----------------------------+
                                |         Passenger            |
                                +-----------------------------+
                                | - passengerId (PK)           |
                                | - flightId (FK)              |
                                | - passengerName              |
                                | - seatNumber                 |
                                +-----------------------------+


### Instructions :

1. **Complétez la colonne "Nom de la méthode JPA"** en dérivant les méthodes à partir des requêtes SQL.
2. Respectez la syntaxe des méthodes JPA avec des préfixes comme findBy, countBy, sumBy, et utilisez les bons opérateurs (And, Or, GreaterThan, etc.).
3. Vous avez 20 questions valant chacune 5 points, pour un total de 100 points.
4. **Classement des questions :**
   - Niveau Facile (1 à 10) : Requêtes simples.
   - Niveau Moyen (11 à 15) : Requêtes avec conditions plus complexes.
   - Niveau Difficile (16 à 20) : Jointures et agrégations.

### Tableau des questions

| **Niveau**   | **Requête SQL**                                                                                                                               | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | SELECT * FROM Airport;                                                                                                                       | Récupérer tous les aéroports.                                         |                                         |
| **Facile**   | SELECT * FROM Flight;                                                                                                                        | Récupérer tous les vols.                                              |                                         |
| **Facile**   | SELECT * FROM Passenger;                                                                                                                     | Récupérer tous les passagers.                                         |                                         |
| **Facile**   | SELECT * FROM Airport WHERE airportId = 1;                                                                                                   | Récupérer un aéroport par son ID.                                     |                                         |
| **Facile**   | SELECT * FROM Flight WHERE flightId = 2;                                                                                                     | Récupérer un vol par son ID.                                          |                                         |
| **Facile**   | SELECT * FROM Passenger WHERE passengerId = 3;                                                                                               | Récupérer un passager par son ID.                                     |                                         |
| **Facile**   | SELECT * FROM Flight WHERE destination = 'Paris';                                                                                            | Récupérer les vols vers Paris.                                        |                                         |
| **Facile**   | SELECT * FROM Passenger WHERE seatNumber = '12A';                                                                                            | Récupérer les passagers ayant le siège '12A'.                         |                                         |
| **Facile**   | SELECT * FROM Flight WHERE departureTime > '2024-01-01';                                                                                     | Rechercher les vols après une date donnée.                            |                                         |
| **Facile**   | SELECT * FROM Passenger WHERE passengerName = 'John';                                                                                        | Rechercher un passager par son nom.                                   |                                         |
| **Moyen**    | SELECT * FROM Flight WHERE destination LIKE 'P%';                                                                                            | Rechercher les vols vers une destination commençant par 'P'.          |                                         |
| **Moyen**    | SELECT * FROM Passenger WHERE seatNumber = '12A' AND flightId = 1;                                                                           | Rechercher les passagers avec un siège spécifique sur un vol donné.   |                                         |
| **Moyen**    | SELECT COUNT(*) FROM Flight WHERE destination = 'New York';                                                                                  | Compter les vols vers New York.                                       |                                         |
| **Moyen**    | SELECT AVG(seatNumber) FROM Passenger WHERE flightId = 1;                                                                                    | Calculer la moyenne des numéros de siège d'un vol spécifique.         |                                         |
| **Moyen**    | SELECT * FROM Flight WHERE departureTime BETWEEN '2024-01-01' AND '2024-12-31';                                                              | Rechercher les vols entre deux dates.                                 |                                         |
| **Difficile**| SELECT * FROM Passenger p JOIN Flight f ON p.flightId = f.flightId WHERE f.destination = 'Paris';                                              | Rechercher les passagers des vols à destination de Paris.             |                                         |
| **Difficile**| SELECT * FROM Airport a JOIN Flight f ON a.airportId = f.airportId WHERE f.destination = 'Tokyo';                                             | Rechercher les aéroports avec des vols à destination de Tokyo.        |                                         |
| **Difficile**| SELECT * FROM Passenger WHERE EXISTS (SELECT 1 FROM Flight WHERE flightId = Passenger.flightId AND destination = 'London');                   | Rechercher les passagers avec un vol à destination de Londres.        |                                         |
| **Difficile**| SELECT COUNT(*) FROM Passenger p WHERE p.flightId = 1;                                                                                       | Compter le nombre de passagers sur un vol spécifique.                 |                                         |
| **Difficile**| SELECT * FROM Flight WHERE destination = 'Paris' ORDER BY departureTime DESC;                                                                | Rechercher les vols vers Paris, triés par ordre décroissant de départ.|                                         |
| **Difficile**| SELECT SUM(seatNumber) FROM Passenger WHERE flightId = 1;                                                                                    | Calculer la somme des numéros de siège d'un vol donné.                |                                         |

### Rappel :

- **Airport** : La classe Airport contient airportId comme clé primaire (PK).
- **Flight** : La classe Flight contient flightId comme clé primaire (PK) et airportId comme clé étrangère (FK).
- **Passenger** : La classe Passenger contient passengerId comme clé primaire (PK) et flightId comme clé étrangère (FK).

### Critères de notation :

- **Total de 100 points**, avec 5 points pour chaque question.
- Les méthodes doivent suivre la convention de nommage de **Spring Data JPA** et utiliser les bons opérateurs.
- L’évaluation inclut des requêtes SQL simples, des jointures, et des agrégations.




















### Liens ancrés ajoutés :

- [Annexe 1 - Méthodes personnalisées dans Spring Data JPA](#annexe-1---méthodes-personnalisées-dans-spring-data-jpa)
- [Exercice 1 - Application JPA avec Customer et Card](#exercice-1---application-jpa-avec-customer-et-card)
- [Exercice 2 - Diagramme de la base de données avec Airport, Flight et Passenger](#exercice-2---diagramme-de-la-base-de-données-avec-airport-flight-et-passenger)
- [Exercice 3 - Jointures dans Spring Data JPA](#exercice-3---jointures-dans-spring-data-jpa)





