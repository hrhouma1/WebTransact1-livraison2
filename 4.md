# Table des Matières

1. [Structure des noms de méthodes](#structure-des-noms-de-méthodes)  
2. [Mots-clés supportés par Spring Data JPA](#mots-clés-supportés-par-spring-data-jpa)  
3. [Combinaison de mots-clés](#combinaison-de-mots-clés)  
4. [Traverser les relations entre entités](#traverser-les-relations-entre-entités)  
5. [Requêtes personnalisées avec `@Query`](#requêtes-personnalisées-avec-query)  
6. [Conseils pratiques pour l'utilisation des conventions de nommage](#conseils-pratiques-pour-lutilisation-des-conventions-de-nommage)  
7. [Cas pratique : gestion des entités `Customer` et `Order`](#cas-pratique--gestion-des-entités-customer-et-order)  
8. [Conclusion](#conclusion)  
9. [Annexe 1 - Méthodes personnalisées dans Spring Data JPA](#annexe-1---méthodes-personnalisées-dans-spring-data-jpa)  
10. [Exercice 1 - Application JPA avec Customer et Card](#exercice-1---application-jpa-avec-customer-et-card)  
11. [Exercice 2 - Diagramme de la base de données avec Airport, Flight et Passenger](#exercice-2---diagramme-de-la-base-de-données-avec-airport-flight-et-passenger)  
12. [Exercice 3 - Jointures dans Spring Data JPA](#exercice-3---jointures-dans-spring-data-jpa)

---


### 1. <a id="structure-des-noms-de-méthodes"></a>Structure des noms de méthodes
[Retour à la table des matières](#table-des-matières)

L'une des principales forces de Spring Data JPA est sa capacité à générer des requêtes dynamiques en analysant simplement le nom des méthodes définies dans les interfaces `Repository`. Cela permet aux développeurs d'écrire des méthodes expressives, sans avoir à manipuler directement du SQL ou JPQL. La structure typique des noms de méthodes suit un modèle prédictif qui combine attributs et opérations.

#### Modèle général de nommage :

```
findBy[Attribut][Opération][AutreAttribut][Opération]...
```

- **`findBy`** : Le préfixe `findBy` indique que vous souhaitez récupérer une ou plusieurs entités en fonction d'un ou plusieurs critères.
- **`Attribut`** : Correspond au nom de l'attribut de l'entité sur lequel la recherche est effectuée. Par exemple, si vous avez une entité `User` avec un champ `lastname`, vous pouvez écrire `findByLastname`.
- **`Opération`** : Indique l'opération à effectuer sur l'attribut (e.g. `LessThan`, `GreaterThan`, `IsNull`), permettant des recherches plus complexes.

#### Exemples de méthodes dérivées :
1. **`findByLastname`** : Cette méthode génère une requête pour retrouver tous les enregistrements où le champ `lastname` correspond à la valeur fournie.
   - JPQL : `SELECT u FROM User u WHERE u.lastname = ?1`

2. **`findByFirstnameAndLastname`** : Recherche d'une entité avec des critères multiples. Ici, la recherche se fait à la fois par prénom (`firstname`) et nom de famille (`lastname`).
   - JPQL : `SELECT u FROM User u WHERE u.firstname = ?1 AND u.lastname = ?2`

3. **`findByAgeLessThanAndFirstnameStartingWith`** : Ici, la méthode combine plusieurs opérations sur différents champs. Elle récupère les entités où l'âge est inférieur à une certaine valeur et où le prénom commence par une chaîne de caractères spécifique.
   - JPQL : `SELECT u FROM User u WHERE u.age < ?1 AND u.firstname LIKE ?2%`

#### Autres préfixes courants :

- **`countBy`** : Retourne le nombre d'entités correspondant aux critères donnés.
  - Ex. : `countByLastname(String lastname)`
- **`existsBy`** : Vérifie si au moins une entité correspondant aux critères existe.
  - Ex. : `existsByLastname(String lastname)`

---

### 2. <a id="mots-clés-supportés-par-spring-data-jpa"></a>Mots-clés supportés par Spring Data JPA
[Retour à la table des matières](#table-des-matières)

Spring Data JPA offre un large éventail de mots-clés qui permettent de spécifier différentes conditions de recherche. Ces mots-clés sont utilisés pour affiner les requêtes sans écrire de code SQL explicite.

Voici quelques-uns des mots-clés les plus courants, avec des exemples de requêtes générées :

| **Mot-clé**          | **Exemple**                        | **JPQL généré**                              |
|----------------------|------------------------------------|----------------------------------------------|
| `And`                | `findByLastnameAndFirstname`       | `... where x.lastname = ?1 and x.firstname = ?2` |
| `Or`                 | `findByLastnameOrFirstname`        | `... where x.lastname = ?1 or x.firstname = ?2`  |
| `Is`, `Equals`       | `findByFirstnameEquals`            | `... where x.firstname = ?1` |
| `Between`            | `findByAgeBetween`                 | `... where x.age between ?1 and ?2`          |
| `LessThan`           | `findByAgeLessThan`                | `... where x.age < ?1`                       |
| `GreaterThan`        | `findByAgeGreaterThan`             | `... where x.age > ?1`                       |
| `IsNull`             | `findByAgeIsNull`                  | `... where x.age is null`                    |
| `Like`               | `findByFirstnameLike`              | `... where x.firstname like ?1`              |
| `In`                 | `findByAgeIn(Collection<Integer> ages)` | `... where x.age in ?1`                    |
| `NotIn`              | `findByAgeNotIn(Collection<Integer> ages)` | `... where x.age not in ?1`              |
| `True`               | `findByActiveTrue()`               | `... where x.active = true`                  |
| `False`              | `findByActiveFalse()`              | `... where x.active = false`                 |
| `IgnoreCase`         | `findByLastnameIgnoreCase`         | `... where lower(x.lastname) = lower(?1)`    |

#### Points clés :
- **Opérateurs relationnels** : `GreaterThan`, `LessThan`, `Between`, `IsNull`, etc., permettent d'appliquer des conditions numériques ou de date.
- **Opérateurs de chaîne** : `Like`, `StartingWith`, `EndingWith`, etc., permettent de manipuler les chaînes de caractères dans les requêtes.
- **Gestion de la casse** : `IgnoreCase` permet d'ignorer la casse des champs de type chaîne.

---

### 3. <a id="combinaison-de-mots-clés"></a>Combinaison de mots-clés
[Retour à la table des matières](#table-des-matières)

Il est possible de combiner plusieurs mots-clés dans une méthode pour obtenir des requêtes plus complexes, à la fois sur plusieurs attributs et avec différentes opérations. Cela permet d'ajuster précisément les conditions de recherche.

#### Exemples :

1. **`findByLastnameAndFirstnameAllIgnoreCase`**
   - Cette méthode recherche les entités où le nom de famille et le prénom correspondent, en ignorant la casse. Elle combine les mots-clés `And` et `IgnoreCase`.
   - JPQL généré : `SELECT u FROM User u WHERE lower(u.lastname) = lower(?1) AND lower(u.firstname) = lower(?2)`

2. **`findByAgeLessThanAndLastnameStartingWith`**
   - Ici, la recherche se fait en deux étapes : la première vérifie si l'âge est inférieur à une valeur donnée, et la seconde s'assure que le nom de famille commence par une chaîne spécifique.
   - JPQL généré : `SELECT u FROM User u WHERE u.age < ?1 AND u.lastname LIKE ?2%`

3. **`findByCreateDateBetweenAndStatusIn`**
   - Recherche des entités dont la date de création est comprise entre deux valeurs, et dont le statut appartient à une liste prédéfinie.
   - JPQL généré : `SELECT u FROM Entity u WHERE u.createDate BETWEEN ?1 AND ?2 AND u.status IN ?3`

---

### 4. <a id="traverser-les-relations-entre-entités"></a>Traverser les relations entre entités
[Retour à la table des matières](#table-des-matières)

Dans Spring Data JPA, il est également possible de traverser les relations entre entités pour interroger des tables liées. Ceci est particulièrement utile pour les relations **OneToMany** et **ManyToOne**, où les entités sont liées entre elles.

#### Exemple :

Supposons que vous ayez deux entités : `Product` et `Category`. Un produit peut appartenir à une ou plusieurs catégories.

```java
@Entity
public class Product {
    @Id
    private Long id;

    @ManyToOne
    private Category category;
}
```

Vous pouvez écrire une méthode dans le repository qui traverse la relation entre `Product` et `Category` :

```java
List<Product> findByCategoryName(String categoryName);
```

- **Explication** : Spring Data JPA comprendra qu'il doit utiliser la relation entre `Product` et `Category` pour générer une requête qui recherche des produits appartenant à une catégorie dont le nom est spécifié.
- **JPQL généré** : `SELECT p FROM Product p JOIN p.category c WHERE c.name = ?1`

---

### 5. <a id="requêtes-personnalisées-avec-query"></a>Requêtes personnalisées avec `@Query`
[Retour à la table des matières](#table-des-matières)

Bien que les méthodes dérivées soient très puissantes, elles ne couvrent pas tous les cas d'utilisation, surtout lorsque vous devez exécuter des requêtes plus complexes. Dans ces cas, vous pouvez utiliser l'annotation `@Query` pour définir des requêtes JPQL personnalisées.

#### Exemple de JPQL :

```java
@Query("SELECT p FROM Product p WHERE p.name = ?1")
List<Product> findByName(String name);
```

- **Explication** : Ici, vous spécifiez explicitement une requête JPQL qui sélectionne tous les produits dont le nom correspond à la valeur fournie.
- **JPQL généré** : `SELECT p FROM Product p WHERE p.name = ?1`

#### Exemple de SQL natif :

Si vous avez besoin d'utiliser du SQL natif, vous pouvez le faire en définissant la propriété `nativeQuery = true`.

```

java
@Query(value = "SELECT * FROM product WHERE price = :price", nativeQuery = true)
List<Product> findByPriceNative(@Param("price") BigDecimal price);
```

- **Explication** : Ici, vous utilisez une requête SQL classique, plutôt que JPQL, pour interroger la base de données directement.

---

### 6. <a id="conseils-pratiques-pour-lutilisation-des-conventions-de-nommage"></a>Conseils pratiques pour l'utilisation des conventions de nommage
[Retour à la table des matières](#table-des-matières)

#### 1. **Simplicité avant tout**
   - Utilisez les conventions de nommage pour des cas simples. Par exemple, au lieu de créer une requête personnalisée pour une recherche par nom, utilisez simplement `findByLastname`.

#### 2. **Complexité et flexibilité**
   - Si vos besoins deviennent plus complexes, commencez par utiliser les méthodes dérivées. Si cela ne suffit pas, utilisez des requêtes JPQL via l'annotation `@Query`.

#### 3. **Performance**
   - Évitez d'utiliser des méthodes dérivées pour des requêtes très complexes qui nécessitent de multiples jointures ou opérations coûteuses. Dans ces cas, une requête SQL ou JPQL bien optimisée sera plus performante.

#### 4. **Cohérence**
   - Maintenez des noms de méthodes cohérents pour garantir la lisibilité du code. Préférez des noms explicites et descriptifs comme `findByFirstnameAndLastname` à des noms courts mais peu clairs.







### 7. <a id="cas-pratique--gestion-des-entités-customer-et-order"></a>Cas pratique : gestion des entités `Customer` et `Order`
[Retour à la table des matières](#table-des-matières)

Dans cette section, nous allons examiner un exemple pratique d'utilisation des conventions de nommage Spring Data JPA pour gérer des entités liées : `Customer` et `Order`. L'objectif est de démontrer comment les méthodes dérivées peuvent être utilisées pour interroger les données à partir de relations entre entités.

#### Diagramme de la relation entre `Customer` et `Order`

```
+------------------------+              +-------------------------+
|        Customer         |              |          Order           |
+------------------------+              +-------------------------+
| - customerId (PK)       | <----------- | - orderId (PK)           |
| - customerFirstName     |              | - customerId (FK)        |
| - customerLastName      |              | - orderDate              |
| - email                 |              | - totalAmount            |
+------------------------+              +-------------------------+
```

- **Customer** : Représente un client avec un identifiant unique (`customerId`), un prénom, un nom de famille, et un email.
- **Order** : Représente une commande passée par un client. Elle est liée à un client via `customerId` et possède des attributs supplémentaires comme la date de la commande (`orderDate`) et le montant total de la commande (`totalAmount`).

#### Méthodes dérivées pour la gestion des relations

##### 1. **Rechercher des clients par nom et ville**
Cette méthode permet de rechercher des clients en fonction de leur nom de famille et de leur ville de résidence.

```java
List<Customer> findByLastnameAndCity(String lastname, String city);
```

- **Explication** : Cette méthode génère une requête pour récupérer tous les clients dont le nom de famille et la ville correspondent aux valeurs spécifiées.
- **JPQL généré** : `SELECT c FROM Customer c WHERE c.lastname = ?1 AND c.city = ?2`

##### 2. **Rechercher des commandes avec montant minimum**
Cette méthode permet de récupérer les commandes passées par un client dont le montant total dépasse une certaine valeur.

```java
List<Order> findByCustomerAndTotalAmountGreaterThan(Customer customer, BigDecimal amount);
```

- **Explication** : Cette méthode utilise une relation entre `Customer` et `Order` pour trouver toutes les commandes passées par un client spécifique et dont le montant total dépasse la valeur fournie.
- **JPQL généré** : `SELECT o FROM Order o WHERE o.customer = ?1 AND o.totalAmount > ?2`

##### 3. **Requête personnalisée pour des commandes entre deux dates**
Parfois, les méthodes dérivées ne couvrent pas tous les cas d'utilisation, comme les recherches complexes avec des plages de dates. Voici comment utiliser l'annotation `@Query` pour personnaliser une requête.

```java
@Query("SELECT o FROM Order o WHERE o.orderDate BETWEEN ?1 AND ?2")
List<Order> findOrdersBetweenDates(LocalDate startDate, LocalDate endDate);
```

- **Explication** : Cette requête permet de rechercher toutes les commandes passées entre deux dates spécifiques.
- **JPQL généré** : `SELECT o FROM Order o WHERE o.orderDate BETWEEN ?1 AND ?2`

##### 4. **Rechercher les commandes d'un client par date**
Si vous souhaitez lister toutes les commandes passées par un client à une certaine date, voici une méthode dérivée simple.

```java
List<Order> findByCustomerAndOrderDate(Customer customer, LocalDate orderDate);
```

- **Explication** : Cette méthode génère une requête pour récupérer les commandes passées par un client particulier à une date spécifique.
- **JPQL généré** : `SELECT o FROM Order o WHERE o.customer = ?1 AND o.orderDate = ?2`

##### 5. **Rechercher des clients avec des commandes d'un certain montant**
Si vous souhaitez récupérer une liste de clients qui ont passé des commandes dont le montant dépasse une certaine somme, vous pouvez utiliser la relation entre `Customer` et `Order`.

```java
List<Customer> findDistinctByOrdersTotalAmountGreaterThan(BigDecimal amount);
```

- **Explication** : Cette méthode permet de récupérer tous les clients ayant passé au moins une commande d'un montant supérieur à une certaine valeur. Le mot-clé `Distinct` garantit que chaque client est listé une seule fois, même s'il a passé plusieurs commandes répondant à ce critère.
- **JPQL généré** : `SELECT DISTINCT c FROM Customer c JOIN c.orders o WHERE o.totalAmount > ?1`

#### Traverser la relation entre `Customer` et `Order`
Dans cet exemple, nous avons deux entités qui sont liées par une relation **OneToMany** : un client peut passer plusieurs commandes, mais une commande est liée à un seul client.

Si vous souhaitez interroger des données en traversant cette relation, vous pouvez utiliser des méthodes dérivées ou écrire des requêtes personnalisées avec `@Query` pour exploiter pleinement la puissance de Spring Data JPA.

##### Exercice pratique
Essayez de définir les méthodes suivantes dans un `Repository` pour interroger les relations entre les entités `Customer` et `Order`.

1. **Lister toutes les commandes d'un client spécifique**
   - Méthode : `List<Order> findByCustomer(Customer customer);`
   - Objectif : Récupérer toutes les commandes d'un client donné.

2. **Rechercher les clients ayant passé des commandes après une certaine date**
   - Méthode : `List<Customer> findByOrdersOrderDateAfter(LocalDate date);`
   - Objectif : Lister tous les clients ayant passé des commandes après une date donnée.

3. **Compter les commandes d'un client spécifique**
   - Méthode : `Long countByCustomer(Customer customer);`
   - Objectif : Compter combien de commandes un client a passées.

4. **Rechercher les commandes dont le montant est dans une certaine fourchette**
   - Méthode : `List<Order> findByTotalAmountBetween(BigDecimal min, BigDecimal max);`
   - Objectif : Lister toutes les commandes dont le montant total est compris entre deux valeurs.

---

### 8. <a id="conclusion"></a>Conclusion
[Retour à la table des matières](#table-des-matières)

Spring Data JPA offre une approche puissante et intuitive pour la gestion des données dans les applications Java, en particulier lorsqu'il s'agit de manipuler des entités liées par des relations. Grâce à son mécanisme de dérivation des méthodes basé sur les conventions de nommage, il est possible de générer des requêtes SQL complexes sans écrire de SQL explicite.

#### Points clés à retenir :
1. **Simplicité** : Les méthodes dérivées permettent de manipuler les données de manière expressive et intuitive. Il est possible de générer des requêtes complexes simplement en combinant des mots-clés dans le nom des méthodes.
   
2. **Flexibilité** : Lorsqu'une requête dépasse les capacités des méthodes dérivées, vous pouvez utiliser l'annotation `@Query` pour définir des requêtes JPQL ou SQL natives, ce qui donne une flexibilité totale.

3. **Traverser les relations** : Spring Data JPA permet de naviguer facilement entre les entités liées par des relations **OneToMany** ou **ManyToOne**. Vous pouvez ainsi interroger des données d'entités liées sans avoir à écrire de SQL complexe.

4. **Maintenance et lisibilité** : Le code reste lisible et maintenable grâce aux conventions de nommage cohérentes et explicites. Les développeurs peuvent comprendre facilement ce que fait une méthode simplement en regardant son nom.

En conclusion, Spring Data JPA est un atout majeur pour tout projet Java, car il réduit la complexité et améliore la productivité tout en assurant la performance et la maintenabilité des applications.

-----------------------------
# Table détaillée
-----------------------------

Je vous présente une table détaillée des méthodes dérivées Spring Data JPA et des requêtes SQL équivalentes basées sur les exemples fournis dans la section de gestion des entités `Customer` et `Order`, ainsi que des exemples supplémentaires pour illustrer davantage les possibilités.

| **Méthode Spring Data JPA**                                      | **Requête SQL équivalente**                                                                                           | **Description**                                                                                                       |
|-------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| `findByLastnameAndCity(String lastname, String city)`             | `SELECT * FROM Customer WHERE lastname = ? AND city = ?`                                                              | Récupère tous les clients avec le nom de famille et la ville spécifiés.                                               |
| `findByCustomerAndTotalAmountGreaterThan(Customer customer, BigDecimal amount)` | `SELECT * FROM Order WHERE customer_id = ? AND total_amount > ?`                                                      | Récupère toutes les commandes passées par un client spécifique dont le montant total dépasse un certain seuil.        |
| `findOrdersBetweenDates(LocalDate startDate, LocalDate endDate)`  | `SELECT * FROM Order WHERE order_date BETWEEN ? AND ?`                                                                | Récupère toutes les commandes dont la date de commande est comprise entre deux dates.                                 |
| `findByCustomerAndOrderDate(Customer customer, LocalDate orderDate)` | `SELECT * FROM Order WHERE customer_id = ? AND order_date = ?`                                                        | Récupère toutes les commandes passées par un client à une date spécifique.                                            |
| `findDistinctByOrdersTotalAmountGreaterThan(BigDecimal amount)`   | `SELECT DISTINCT c.* FROM Customer c JOIN Order o ON c.customer_id = o.customer_id WHERE o.total_amount > ?`           | Récupère tous les clients ayant passé au moins une commande d'un montant supérieur à un certain seuil.                |
| `findByOrdersOrderDateAfter(LocalDate date)`                      | `SELECT * FROM Customer c JOIN Order o ON c.customer_id = o.customer_id WHERE o.order_date > ?`                        | Récupère tous les clients ayant passé des commandes après une certaine date.                                          |
| `countByCustomer(Customer customer)`                              | `SELECT COUNT(*) FROM Order WHERE customer_id = ?`                                                                    | Compte le nombre de commandes passées par un client spécifique.                                                       |
| `findByTotalAmountBetween(BigDecimal min, BigDecimal max)`         | `SELECT * FROM Order WHERE total_amount BETWEEN ? AND ?`                                                              | Récupère toutes les commandes dont le montant total est compris entre deux valeurs.                                   |
| `findByLastname(String lastname)`                                 | `SELECT * FROM Customer WHERE lastname = ?`                                                                           | Récupère tous les clients avec un nom de famille spécifique.                                                         |
| `findByFirstnameAndLastname(String firstname, String lastname)`   | `SELECT * FROM Customer WHERE firstname = ? AND lastname = ?`                                                         | Récupère tous les clients dont le prénom et le nom de famille correspondent aux valeurs fournies.                     |
| `findByAgeLessThanAndFirstnameStartingWith(int age, String prefix)` | `SELECT * FROM Customer WHERE age < ? AND firstname LIKE ?%`                                                          | Récupère les clients dont l'âge est inférieur à une certaine valeur et dont le prénom commence par un préfixe donné.  |
| `findByOrdersOrderDateBetween(LocalDate startDate, LocalDate endDate)` | `SELECT * FROM Order WHERE order_date BETWEEN ? AND ?`                                                                | Récupère toutes les commandes passées dans une plage de dates donnée.                                                 |
| `findByEmail(String email)`                                       | `SELECT * FROM Customer WHERE email = ?`                                                                              | Récupère un client spécifique basé sur son adresse email.                                                            |
| `findTop5ByOrderByTotalAmountDesc()`                              | `SELECT * FROM Order ORDER BY total_amount DESC LIMIT 5`                                                              | Récupère les 5 commandes les plus importantes en termes de montant total.                                             |
| `findByOrdersOrderDateBefore(LocalDate date)`                     | `SELECT * FROM Customer c JOIN Order o ON c.customer_id = o.customer_id WHERE o.order_date < ?`                        | Récupère tous les clients ayant passé des commandes avant une certaine date.                                          |
| `findByOrdersCustomerCustomerId(Long customerId)`                 | `SELECT * FROM Order WHERE customer_id = ?`                                                                           | Récupère toutes les commandes passées par un client avec un `customerId` donné.                                       |
| `countByOrdersOrderDate(LocalDate orderDate)`                     | `SELECT COUNT(*) FROM Order WHERE order_date = ?`                                                                     | Compte toutes les commandes passées à une date spécifique.                                                           |
| `sumByCustomer(Customer customer)`                                | `SELECT SUM(total_amount) FROM Order WHERE customer_id = ?`                                                           | Calcule la somme des montants des commandes d'un client spécifique.                                                   |

### Explication détaillée des requêtes :

1. **Récupérer un client avec nom et ville** : La méthode `findByLastnameAndCity` génère une requête SQL qui cherche un client avec un nom de famille et une ville spécifique.
2. **Commandes d'un client avec montant minimum** : La méthode `findByCustomerAndTotalAmountGreaterThan` est utile pour obtenir toutes les commandes dont le montant dépasse une valeur donnée pour un client précis.
3. **Rechercher des commandes entre deux dates** : La méthode `findOrdersBetweenDates` récupère toutes les commandes passées entre deux dates, une fonctionnalité souvent nécessaire dans les systèmes de gestion de commandes.
4. **Récupérer les commandes d'un client à une date spécifique** : La méthode `findByCustomerAndOrderDate` permet de lister les commandes d'un client à une date donnée.
5. **Rechercher des clients avec commandes d'un montant élevé** : La méthode `findDistinctByOrdersTotalAmountGreaterThan` récupère les clients ayant passé au moins une commande dont le montant dépasse une certaine somme.

### Ajout de méthodes supplémentaires :
Ces exemples montrent que Spring Data JPA permet de simplifier l'écriture de requêtes SQL complexes via des conventions de nommage, tout en gérant des relations entre entités (comme `Customer` et `Order` dans ce cas).

En combinant ces méthodes avec des fonctionnalités avancées comme `@Query`, vous pouvez obtenir la flexibilité et la simplicité nécessaires pour implémenter des fonctionnalités avancées sans avoir à écrire des requêtes SQL complexes à chaque fois.



---------------------------------
# Annexe 1 : Quand et pourquoi écrire une méthode personnalisée comme `findByCustomerId` dans un Repository Spring Data JPA
---------------------------------



## 1. Introduction à Spring Data JPA et les Repositories

Spring Data JPA est un sous-ensemble du projet Spring Data, conçu pour simplifier l'accès aux bases de données dans les applications Java en utilisant l'API Java Persistence (JPA). Ce framework offre une abstraction puissante pour interagir avec les bases de données sans écrire directement de requêtes SQL complexes.

L'un des avantages majeurs de Spring Data JPA est la prise en charge des **Repositories**, des interfaces qui facilitent la gestion des entités via des méthodes CRUD (Create, Read, Update, Delete). En étendant les interfaces comme `CrudRepository` ou `JpaRepository`, vous bénéficiez automatiquement d'un ensemble de méthodes prédéfinies pour les opérations courantes sans avoir à les implémenter manuellement.

## 2. Les Méthodes par Défaut de `CrudRepository`

Lorsque vous étendez `CrudRepository`, vous obtenez des méthodes de base pour manipuler vos entités dans la base de données, comme par exemple :

- **`save(S entity)`** : Sauvegarder ou mettre à jour une entité dans la base de données.
- **`findById(ID id)`** : Récupérer une entité par son identifiant unique.
- **`findAll()`** : Récupérer toutes les entités d'un type donné.
- **`deleteById(ID id)`** : Supprimer une entité de la base de données par son identifiant.

Ces méthodes couvrent les besoins CRUD basiques pour la majorité des applications. Toutefois, il existe des cas où des requêtes plus spécifiques sont nécessaires. Ces requêtes, qui ne sont pas directement couvertes par les méthodes par défaut, nécessitent l'écriture de méthodes personnalisées dans vos Repositories.

## 3. Quand et pourquoi écrire une méthode personnalisée comme `findByCustomerId` ?

### Quand utiliser des méthodes personnalisées ?

Vous devez écrire une méthode personnalisée lorsque les méthodes CRUD prédéfinies ne suffisent pas pour couvrir les besoins spécifiques de votre application. Voici quelques cas d'usage typiques :

- **Requêtes basées sur des champs autres que l'ID primaire** : Si vous devez interroger la base de données en fonction d'un champ autre que l'ID, par exemple, pour rechercher un client en fonction de son ID de client (`customerId`) plutôt que de l'ID du compte (`accountId`).
- **Simplification de l'accès aux données** : Plutôt que d'écrire des requêtes SQL manuelles à chaque fois, vous pouvez automatiser la création de requêtes en utilisant les conventions de nommage de Spring Data JPA.
- **Conditions spécifiques et requêtes complexes** : Pour les cas où vous devez appliquer des conditions supplémentaires ou combiner plusieurs colonnes dans une requête.

Exemple :  
```java
Accounts findByCustomerId(int customerId);
```

### Pourquoi le `Repository` ne contient-il que `findByCustomerId` ?

La méthode `findByCustomerId` est un exemple de méthode personnalisée générée automatiquement par Spring Data JPA en se basant sur le nom de la méthode. Les autres méthodes telles que `save()`, `findAll()` ou `deleteById()` ne sont pas explicitement visibles dans votre Repository, car elles sont héritées de l'interface `CrudRepository` ou `JpaRepository`. Ces méthodes existent, mais il n'est pas nécessaire de les réécrire ou de les déclarer à moins que vous ne vouliez modifier leur comportement par défaut.

## 4. Comment écrire une méthode personnalisée ?

Spring Data JPA permet de définir des méthodes personnalisées en suivant des **conventions de nommage** claires. Cela signifie que vous n'avez pas besoin d'écrire explicitement les requêtes SQL : le nom de la méthode sert à générer automatiquement la requête correspondante.

Voici un exemple de méthode personnalisée pour rechercher un compte par `customerId` :
```java
Accounts findByCustomerId(int customerId);
```

### Explication :
- **`findBy`** : Indique que vous voulez effectuer une recherche.
- **`CustomerId`** : Spécifie le champ sur lequel la recherche doit être effectuée (dans ce cas, `customerId`).

### Cas pratiques supplémentaires :
- **Recherche par plusieurs champs** :
  ```java
  Accounts findByCustomerIdAndAccountType(int customerId, String accountType);
  ```
  Cette méthode génère une requête qui récupère les comptes avec un `customerId` et un `accountType` spécifiques.

- **Recherche partielle sur un champ** :
  ```java
  List<Accounts> findByBranchAddressContaining(String addressFragment);
  ```
  Cette méthode permet de rechercher des comptes où l'adresse de la branche (`branchAddress`) contient une certaine chaîne de caractères.

- **Recherche en fonction de dates** :
  ```java
  List<Accounts> findByCreateDtAfter(LocalDate date);
  ```
  Cette méthode récupère tous les comptes créés après une date donnée.

## 5. Exemples de Méthodes Personnalisées

Spring Data JPA permet de créer des méthodes très puissantes avec peu de code. Voici quelques exemples qui montrent la diversité des requêtes que vous pouvez générer grâce aux conventions de nommage :

- **Recherche par plusieurs attributs avec des conditions complexes** :
  ```java
  List<Accounts> findByCustomerIdAndAccountTypeOrBranchAddress(String customerId, String accountType, String branchAddress);
  ```
  Génère une requête qui recherche des comptes correspondant à un `customerId` et un `accountType` spécifiques, ou dont l'adresse de la branche correspond à une certaine valeur.

- **Requête avec des plages de valeurs** :
  ```java
  List<Accounts> findByTotalLimitBetween(double minLimit, double maxLimit);
  ```
  Récupère les comptes dont la limite totale est comprise entre deux valeurs.

- **Requête avec des conditions temporelles** :
  ```java
  List<Accounts> findByCreateDtBefore(LocalDate date);
  ```
  Cette méthode retourne tous les comptes créés avant une certaine date.

## 6. Avantages des Méthodes Personnalisées

L'utilisation de méthodes personnalisées dans un Repository offre plusieurs avantages :

- **Lisibilité** : En nommant clairement vos méthodes, le code devient plus lisible. Les noms explicites des méthodes indiquent exactement ce que fait la requête.
- **Réutilisabilité** : Une fois que vous avez défini une méthode dans un Repository, vous pouvez la réutiliser partout dans votre application, sans avoir à réécrire des requêtes SQL complexes.
- **Maintenance simplifiée** : En utilisant des méthodes personnalisées, vous évitez de disperser des requêtes SQL dans tout votre code. Cela facilite la maintenance et l'évolution de votre application.

## 7. Quand ne pas écrire de Méthodes Personnalisées ?

Il est important de comprendre que les méthodes personnalisées ne sont pas toujours nécessaires :

- **Lorsque les méthodes par défaut suffisent** : Si les méthodes héritées de `CrudRepository` couvrent vos besoins, il n'est pas nécessaire d'écrire des méthodes personnalisées. Par exemple, si vous devez simplement récupérer un enregistrement par son ID, `findById()` suffit.
  
- **Lorsque les requêtes sont très complexes** : Dans certains cas, les conventions de nommage ne sont pas suffisantes pour générer des requêtes SQL très complexes. Dans ces situations, vous devrez peut-être utiliser l'annotation `@Query` pour écrire des requêtes JPQL personnalisées, ou même passer à la **Criteria API**.

## 8. Conclusion

Spring Data JPA offre une grande flexibilité avec ses conventions de nommage pour les méthodes de Repository. Écrire des méthodes personnalisées vous permet de répondre à des besoins spécifiques sans avoir à écrire de SQL complexe à la main. En plus de rendre le code plus lisible et plus maintenable, cette approche réduit également la duplication des requêtes à travers l'application.

Lorsque vous avez besoin de requêtes plus complexes ou spécifiques, les méthodes personnalisées sont la solution idéale. Mais si les méthodes CRUD de base suffisent, il est tout aussi efficace d'utiliser les méthodes par défaut de `CrudRepository` ou `JpaRepository`.






-------------------------
# Exercice 1 : Application JPA - Gestion des entités Customer et Card
-------------------------

Cet exercice vous permettra de progresser de requêtes SQL simples à des requêtes plus complexes, en vous concentrant sur l’utilisation des conventions de nommage de Spring Data JPA pour générer automatiquement des méthodes dans vos repositories.

Vous allez compléter les noms de méthodes JPA basés sur les requêtes SQL ci-dessous.

## Diagramme de base de données

Le diagramme suivant présente la relation entre deux entités : `Customer` et `Card`. Un client peut avoir plusieurs cartes, et chaque carte est associée à un client.

```
+--------------------------+             +--------------------------+
|        Customer           |             |          Card             |
+--------------------------+             +--------------------------+
| - customerId (PK)         | <-----------| - cardId (PK)             |
| - customerFirstName       |             | - customerId (FK)         |
| - customerLastName        |             | - cardNumber              |
+--------------------------+             | - cardType                |
                                          | - totalLimit              |
                                          | - amountUsed              |
                                          | - availableAmount         |
                                          | - createDt                |
                                          +--------------------------+
```

- **Customer** : La classe Customer contient `customerId` comme clé primaire (PK).
- **Card** : La classe Card contient `cardId` comme clé primaire (PK) et `customerId` comme clé étrangère (FK) qui fait référence à `Customer`.

## Tableau des requêtes et des méthodes JPA

| **Niveau**   | **Requête SQL**                                                                                                                                  | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | `SELECT * FROM Customer;`                                                                                                                        | Récupérer tous les clients.                                           | `findAll()`                            |
| **Facile**   | `SELECT * FROM Card;`                                                                                                                            | Récupérer toutes les cartes.                                          | `findAll()`                            |
| **Facile**   | `SELECT * FROM Customer WHERE customerId = 1;`                                                                                                   | Récupérer un client par son ID.                                       | `findByCustomerId(Long customerId)`    |
| **Facile**   | `SELECT * FROM Card WHERE cardId = 2;`                                                                                                           | Récupérer une carte par son ID.                                       | `findByCardId(Long cardId)`            |
| **Facile**   | `SELECT * FROM Customer WHERE customerFirstName = 'John';`                                                                                       | Rechercher un client par son prénom.                                  | `findByCustomerFirstName(String firstName)` |
| **Facile**   | `SELECT * FROM Customer WHERE customerLastName = 'Doe';`                                                                                         | Rechercher un client par son nom de famille.                          | `findByCustomerLastName(String lastName)` |
| **Facile**   | `SELECT * FROM Card WHERE customerId = 1;`                                                                                                       | Rechercher toutes les cartes d'un client spécifique.                  | `findByCustomerCustomerId(Long customerId)` |
| **Facile**   | `SELECT * FROM Card WHERE cardNumber = '1234567890';`                                                                                            | Rechercher une carte par son numéro.                                  | `findByCardNumber(String cardNumber)`  |
| **Facile**   | `SELECT * FROM Card WHERE cardType = 'Gold';`                                                                                                    | Rechercher toutes les cartes de type "Gold".                          | `findByCardType(String cardType)`      |
| **Facile**   | `SELECT * FROM Customer WHERE customerFirstName = 'John' AND customerLastName = 'Doe';`                                                          | Rechercher un client par son prénom et son nom de famille.            | `findByCustomerFirstNameAndCustomerLastName(String firstName, String lastName)` |
| **Facile**   | `SELECT * FROM Customer WHERE customerFirstName LIKE 'J%';`                                                                                      | Rechercher les clients dont le prénom commence par 'J'.               | `findByCustomerFirstNameStartingWith(String prefix)` |
| **Facile**   | `SELECT * FROM Card WHERE totalLimit = 10000;`                                                                                                   | Rechercher les cartes avec une limite totale de 10000.                | `findByTotalLimit(Double totalLimit)`  |
| **Moyen**    | `SELECT * FROM Card WHERE availableAmount > 500;`                                                                                                | Rechercher les cartes avec un montant disponible supérieur à 500.     | `findByAvailableAmountGreaterThan(Double amount)` |
| **Moyen**    | `SELECT * FROM Card WHERE amountUsed < 2000;`                                                                                                    | Rechercher les cartes avec un montant utilisé inférieur à 2000.       | `findByAmountUsedLessThan(Double amount)` |
| **Moyen**    | `SELECT * FROM Card WHERE createDt > '2024-01-01';`                                                                                              | Rechercher les cartes créées après une date spécifique.               | `findByCreateDtAfter(LocalDate date)`  |
| **Moyen**    | `SELECT * FROM Customer WHERE customerLastName = 'Smith' OR customerLastName = 'Doe';`                                                           | Rechercher les clients avec les noms de famille 'Smith' ou 'Doe'.     | `findByCustomerLastNameIn(List<String> lastNames)` |
| **Moyen**    | `SELECT * FROM Card WHERE totalLimit > 3000 AND totalLimit < 7000;`                                                                              | Rechercher les cartes avec une limite totale comprise entre 3000 et 7000. | `findByTotalLimitBetween(Double min, Double max)` |
| **Moyen**    | `SELECT * FROM Card WHERE cardType = 'Gold' AND totalLimit > 5000;`                                                                              | Rechercher les cartes de type "Gold" avec une limite totale supérieure à 5000. | `findByCardTypeAndTotalLimitGreaterThan(String cardType, Double totalLimit)` |
| **Moyen**    | `SELECT * FROM Customer WHERE customerFirstName IN ('John', 'Jane', 'Jim');`                                                                     | Rechercher les clients avec une liste de prénoms spécifiques.         | `findByCustomerFirstNameIn(List<String> firstNames)` |
| **Moyen**    | `SELECT COUNT(*) FROM Card WHERE cardType = 'Platinum';`                                                                                         | Compter le nombre de cartes de type "Platinum".                      | `countByCardType(String cardType)`     |
| **Moyen**    | `SELECT AVG(totalLimit) FROM Card WHERE cardType = 'Gold';`                                                                                      | Calculer la limite totale moyenne des cartes de type "Gold".          | `findAvgTotalLimitByCardType(String cardType)` |
| **Difficile**| `SELECT * FROM Customer c JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardType = 'Gold';`                                               | Rechercher les clients ayant une carte de type "Gold".                | `findByCardsCardType(String cardType)` |
| **Difficile**| `SELECT * FROM Customer WHERE EXISTS (SELECT 1 FROM Card WHERE customerId = Customer.customerId AND cardType = 'Platinum');`                     | Rechercher les clients ayant au moins une carte de type "Platinum".   | `findByCardsCardTypeExists(String cardType)` |
| **Difficile**| `SELECT * FROM Card WHERE amountUsed > 1000 AND availableAmount < 500;`                                                                          | Rechercher les cartes avec un montant utilisé supérieur à 1000 et un montant disponible inférieur à 500. | `findByAmountUsedGreaterThanAndAvailableAmountLessThan(Double used, Double available)` |
| **Difficile**| `SELECT c.* FROM Customer c LEFT JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardId IS NULL;`                                           | Rechercher les clients n'ayant aucune carte associée.                 | `findByCardsIsNull()`                  |
| **Difficile**| `SELECT * FROM Card WHERE createDt BETWEEN '2024-01-01' AND '2024-12-31';`                                                                       | Rechercher les cartes créées dans l'année 2024.                       | `findByCreateDtBetween(LocalDate start, LocalDate end)` |
| **Difficile**| `SELECT * FROM Card WHERE availableAmount > 1000 ORDER BY availableAmount DESC;`                                                                 | Rechercher les cartes avec un montant disponible supérieur à 1000, triées par montant décroissant. | `findByAvailableAmountGreaterThanOrderByAvailableAmountDesc(Double amount)` |
| **Difficile**| `SELECT * FROM Customer c JOIN Card ca ON c.customerId = ca.customerId WHERE ca.cardType = 'Gold' AND ca.totalLimit > 5000 ORDER BY c.customerLastName;` | Rechercher les clients ayant une carte "Gold" avec une limite totale supérieure à 5000, triés par nom de famille. | `findByCardsCardTypeAndTotalLimitGreaterThanOrderByCustomerLastName(String cardType, Double limit)` |
| **Difficile**| `SELECT SUM(availableAmount) FROM Card WHERE customerId = 1;`                                                                                    | Calculer le montant disponible total des cartes d'un client spécifique. | `sumByCustomerId(Long customerId)`     |
| **Difficile**| `SELECT * FROM Card WHERE totalLimit > 5000 AND amountUsed BETWEEN 1000 AND 2000;`                                                               | Rechercher les cartes avec une limite totale supérieure à 5000 et un montant utilisé compris entre 1000 et 2000. | `findByTotalLimitGreaterThanAnd

AmountUsedBetween(Double limit, Double minAmount, Double maxAmount)` |

### Instructions pour les étudiants :

- Complétez la colonne **Nom de la méthode JPA** en dérivant les méthodes à partir des requêtes SQL.
- Respectez la syntaxe des méthodes JPA avec des préfixes comme `findBy`, `countBy`, `sumBy`, et utilisez les bons opérateurs (And, Or, GreaterThan, etc.).


-------------------------
# Exercice 2 : Application JPA - Gestion des entités Airport, Flight et Passenger
-------------------------

Dans cet exercice, vous allez gérer une base de données plus complexe, avec plusieurs entités reliées par des clés étrangères. Vous travaillerez avec les entités `Airport`, `Flight` et `Passenger`, et vous devrez dériver des méthodes JPA à partir des requêtes SQL.

## Diagramme de base de données

Le diagramme suivant présente la relation entre trois entités : `Airport`, `Flight`, et `Passenger`. Un aéroport peut avoir plusieurs vols, et chaque vol peut avoir plusieurs passagers.

```
+-----------------------------+             +-----------------------------+
|           Airport            |             |           Flight            |
+-----------------------------+             +-----------------------------+
| - airportId (PK)             | <-----------| - flightId (PK)             |
| - airportName                |             | - airportId (FK)            |
| - location                   |             | - destination               |
+-----------------------------+             | - departureTime             |
                                             +-----------------------------+
                                             |
                                             v
                                +-----------------------------+
                                |         Passenger            |
                                +-----------------------------+
                                | - passengerId (PK)           |
                                | - flightId (FK)              |
                                | - passengerName              |
                                | - seatNumber                 |
                                +-----------------------------+
```

## Tableau des requêtes et des méthodes JPA

| **Niveau**   | **Requête SQL**                                                                                                                               | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | `SELECT * FROM Airport;`                                                                                                                       | Récupérer tous les aéroports.                                         | `findAll()`                            |
| **Facile**   | `SELECT * FROM Flight;`                                                                                                                        | Récupérer tous les vols.                                              | `findAll()`                            |
| **Facile**   | `SELECT * FROM Passenger;`                                                                                                                     | Récupérer tous les passagers.                                         | `findAll()`                            |
| **Facile**   | `SELECT * FROM Airport WHERE airportId = 1;`                                                                                                   | Récupérer un aéroport par son ID.                                     | `findByAirportId(Long airportId)`      |
| **Facile**   | `SELECT * FROM Flight WHERE flightId = 2;`                                                                                                     | Récupérer un vol par son ID.                                          | `findByFlightId(Long flightId)`        |
| **Facile**   | `SELECT * FROM Passenger WHERE passengerId = 3;`                                                                                               | Récupérer un passager par son ID.                                     | `findByPassengerId(Long passengerId)`  |
| **Facile**   | `SELECT * FROM Flight WHERE destination = 'Paris';`                                                                                            | Récupérer les vols vers Paris.                                        | `findByDestination(String destination)` |
| **Facile**   | `SELECT * FROM Passenger WHERE seatNumber = '12A';`                                                                                            | Récupérer les passagers ayant le siège '12A'.                         | `findBySeatNumber(String seatNumber)`  |
| **Facile**   | `SELECT * FROM Flight WHERE departureTime > '2024-01-01';`                                                                                     | Rechercher les vols après une date donnée.                            | `findByDepartureTimeAfter(LocalDate departureTime)` |
| **Facile**   | `SELECT * FROM Passenger WHERE passengerName = 'John';`                                                                                        | Rechercher un passager par son nom.                                   | `findByPassengerName(String name)`     |
| **Moyen**    | `SELECT * FROM Flight WHERE destination LIKE 'P%';`                                                                                            | Rechercher les vols vers une destination commençant par 'P'.          | `findByDestinationStartingWith(String prefix)` |
| **Moyen**    | `SELECT * FROM Passenger WHERE seatNumber = '12A' AND flightId = 1;`                                                                           | Rechercher les passagers avec un siège spécifique sur un vol donné.   | `findBySeatNumberAndFlightId(String seatNumber, Long flightId)` |
| **Moyen**    | `SELECT COUNT(*) FROM Flight WHERE destination = 'New York';`                                                                                  | Compter les vols vers New York.                                       | `countByDestination(String destination)` |
| **Moyen**    | `SELECT AVG(seatNumber) FROM Passenger WHERE flightId = 1;`                                                                                    | Calculer la moyenne des numéros de siège d'un vol spécifique.         | `findAvgSeatNumberByFlightId(Long flightId)` |
| **Moyen**    | `SELECT * FROM Flight WHERE departureTime BETWEEN '2024-01-01' AND '2024-12-31';`                                                              | Rechercher les vols entre deux dates.                                 | `findByDepartureTimeBetween(LocalDate start, LocalDate end)` |
| **Difficile**| `SELECT * FROM Passenger p JOIN Flight f ON p.flightId = f.flightId WHERE f.destination = 'Paris';`                                              | Rechercher les passagers des vols à destination de Paris.             | `findByFlightDestination(String destination)` |
| **Difficile**| `SELECT * FROM Airport a JOIN Flight f ON a.airportId = f.airportId WHERE f.destination = 'Tokyo';`                                             | Rechercher les aéroports avec des vols à destination de Tokyo.        | `findByFlightsDestination(String destination)` |
| **Difficile**| `SELECT * FROM Passenger WHERE EXISTS (SELECT 1 FROM Flight WHERE flightId = Passenger.flightId AND destination = 'London');`                   | Rechercher les passagers avec un vol à destination de Londres.        | `findByFlightDestinationExists(String destination)` |
| **Difficile**| `SELECT COUNT(*) FROM Passenger p WHERE p.flightId = 1;`                                                                                       | Compter le nombre de passagers sur un vol spécifique.                 | `countByFlightId(Long flightId)`       |
| **Difficile**| `SELECT * FROM Flight WHERE destination = 'Paris' ORDER BY departureTime DESC;`                                                                | Rechercher les vols vers Paris, triés par ordre décroissant de départ.| `findByDestinationOrderByDepartureTimeDesc(String destination)` |
| **Difficile**| `SELECT SUM(seatNumber) FROM Passenger WHERE flightId = 1;`                                                                                    | Calculer la somme des numéros de siège d'un vol donné.                | `sumByFlightId(Long flightId)`         |

### Instructions pour les étudiants :

- Complétez la colonne **Nom de la méthode JPA** en dérivant les méthodes à partir des requêtes SQL.
- Respectez la syntaxe des méthodes JPA avec des préfixes comme `findBy`, `countBy`, `sumBy`, et utilisez les bons opérateurs (And, Or, GreaterThan, etc.).

### Critères de notation :

- Total de 100 points, chaque question valant 5 points.
- Les méthodes doivent suivre la convention de nommage de **Spring Data JPA** et utiliser les bons opérateurs.
- L’évaluation inclut des requêtes SQL simples, des jointures, et des agrégations.


-------------------------
# Exercice 3 + cours :  Jointures dans Spring Data JPA 
-------------------------

Lorsque vous effectuez une jointure dans Spring Data JPA, vous ne mentionnez pas directement l'entité dans laquelle vous vous trouvez (c'est implicite), mais vous utilisez la relation (le nom de l'attribut qui fait référence à l'autre entité) pour traverser la relation.

#### Diagramme des entités : `Employee` et `Department`

Nous allons utiliser deux entités pour illustrer les jointures.

```
+-----------------------------+             +-----------------------------+
|          Employee            |             |        Department           |
+-----------------------------+             +-----------------------------+
| - employeeId (PK)            |             | - departmentId (PK)          |
| - firstName                  |             | - departmentName             |
| - lastName                   |             | - location                   |
| - salary                     |             |                             |
| - departmentId (FK)          |             |                             |
+-----------------------------+             +-----------------------------+
```

Dans cette structure, un employé (*Employee*) est lié à un département (*Department*) via une clé étrangère `departmentId`. Un employé appartient à un seul département, et un département peut avoir plusieurs employés.

### Comment réaliser une jointure avec Spring Data JPA ?

Pour effectuer une jointure entre deux entités dans Spring Data JPA, vous devez comprendre le modèle de relation. Supposons que l'entité `Employee` ait une relation avec `Department` via l'attribut `departmentId`. Vous utiliserez cet attribut pour effectuer la jointure.

#### Exemple de jointure :

- **Nom de la méthode** : `findByDepartmentDepartmentName`
- **Explication** :
  - `findBy` : Indique qu'il s'agit d'une requête de recherche.
  - `Department` : Nom de la relation dans l'entité `Employee` qui fait référence à l'entité `Department`. Il correspond au champ `department` dans `Employee` qui est de type `Department`.
  - `DepartmentName` : Nom de l'attribut dans l'entité `Department` que vous voulez interroger.

La syntaxe pour une jointure est toujours :  
```java
findBy[NomRelation][AttributDansRelation][Opérateur]...
```

**Note importante** : Le nom de la table `Employee` n'est pas mentionné dans la méthode car vous êtes déjà dans le contexte de cette entité (c'est implicite). Vous mentionnez uniquement la relation (`Department`) et l'attribut dans l'autre table (par exemple, `DepartmentName`).

---

### Structure des méthodes pour les jointures :

#### Jointure simple :

```java
findByDepartmentDepartmentName(String departmentName);
```
Cette méthode effectue une jointure entre `Employee` et `Department` et filtre les employés en fonction du nom du département.

#### Jointure avec des conditions supplémentaires :

```java
findBySalaryGreaterThanAndDepartmentDepartmentName(Double salary, String departmentName);
```
Ici, nous combinons une jointure entre `Employee` et `Department` avec une condition sur le salaire de l'employé et le nom du département.

---




### Tableau des requêtes et des méthodes JPA avec jointures

| **Niveau**   | **Requête SQL**                                                                                                                                  | **Indice**                                                          | **Nom de la méthode JPA**              |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-----------------------------------------|
| **Facile**   | `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId;`                                                            | Récupérer tous les employés avec leurs départements.                  | `findAll()`                             |
| **Facile**   | `SELECT e.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'HR';`                                    | Récupérer les employés du département 'HR'.                           | `findByDepartmentDepartmentName(String departmentName)` |
| **Moyen**    | `SELECT e.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE e.salary > 50000 AND d.departmentName = 'IT';`               | Récupérer les employés avec un salaire > 50000 dans 'IT'.             | `findBySalaryGreaterThanAndDepartmentDepartmentName(Double salary, String departmentName)` |
| **Moyen**    | `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE e.salary > 40000;`                                      | Récupérer les employés avec un salaire > 40000.                       | `findBySalaryGreaterThan(Double salary)` |
| **Moyen**    | `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'Finance' ORDER BY e.salary DESC;`   | Récupérer les employés de 'Finance' triés par salaire décroissant.    | `findByDepartmentDepartmentNameOrderBySalaryDesc(String departmentName)` |
| **Difficile**| `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE e.salary > 60000 AND d.departmentName = 'Marketing';`   | Récupérer les employés dans 'Marketing' avec un salaire > 60000.      | `findBySalaryGreaterThanAndDepartmentDepartmentName(Double salary, String departmentName)` |
| **Difficile**| `SELECT COUNT(e.employeeId) FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'HR';`                   | Compter les employés dans le département 'HR'.                        | `countByDepartmentDepartmentName(String departmentName)` |
| **Difficile**| `SELECT SUM(e.salary) FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'IT';`                         | Calculer la somme des salaires dans 'IT'.                             | `sumSalaryByDepartmentDepartmentName(String departmentName)` |
| **Difficile**| `SELECT e.*, d.* FROM Employee e JOIN Department d ON e.departmentId = d.departmentId WHERE d.departmentName = 'HR' AND e.salary BETWEEN 40000 AND 60000;` | Récupérer les employés dans 'HR' avec un salaire compris entre 40000 et 60000. | `findBySalaryBetweenAndDepartmentDepartmentName(Double min, Double max, String departmentName)` |

---

### Explications supplémentaires

1. **Jointure simple** :
   - La méthode `findByDepartmentDepartmentName` réalise une jointure entre `Employee` et `Department` pour rechercher des employés en fonction du nom du département.

2. **Combinaison de jointures et de conditions** :
   - `findBySalaryGreaterThanAndDepartmentDepartmentName` combine une condition de salaire et une jointure sur le nom du département.

3. **Agrégations et comptage** :
   - Les méthodes comme `countByDepartmentDepartmentName` permettent de compter les employés dans un département, et `sumSalaryByDepartmentDepartmentName` calcule la somme des salaires dans un département.
  









---------

Le **nom de la relation** dans une jointure fait référence à l'attribut de votre entité qui établit la relation avec une autre entité. En général, dans une entité JPA, cela se fait via l'annotation `@ManyToOne`, `@OneToMany`, `@OneToOne`, ou `@ManyToMany`, couplée à `@JoinColumn`, qui définit la clé étrangère (foreign key).

Dans l'exemple des entités `Employee` et `Department`, le **nom de la relation** est l'attribut qui fait référence à l'entité `Department` dans `Employee`. Le nom de la relation est généralement le même que le nom de l'attribut qui contient la référence à l'autre entité (ici, `department`). Ce nom est utilisé dans les méthodes de recherche JPA pour effectuer les jointures.

Voici un exemple complet du code des deux entités : `Employee` et `Department`, avec les annotations JPA pour définir la relation.

### Exemple de Code : Entité `Employee`

```java
import javax.persistence.*;

@Entity
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long employeeId;

    private String firstName;
    private String lastName;
    private Double salary;

    // Nom de la relation vers l'entité Department
    @ManyToOne
    @JoinColumn(name = "department_id", referencedColumnName = "departmentId") // Clé étrangère qui référence Department
    private Department department;

    // Getters et setters

    public Long getEmployeeId() {
        return employeeId;
    }

    public void setEmployeeId(Long employeeId) {
        this.employeeId = employeeId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public Double getSalary() {
        return salary;
    }

    public void setSalary(Double salary) {
        this.salary = salary;
    }

    public Department getDepartment() {
        return department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }
}
```

### Exemple de Code : Entité `Department`

```java
import javax.persistence.*;
import java.util.List;

@Entity
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long departmentId;

    private String departmentName;
    private String location;

    // Nom de la relation inverse vers l'entité Employee
    @OneToMany(mappedBy = "department")  // Relation inverse, un département a plusieurs employés
    private List<Employee> employees;

    // Getters et setters

    public Long getDepartmentId() {
        return departmentId;
    }

    public void setDepartmentId(Long departmentId) {
        this.departmentId = departmentId;
    }

    public String getDepartmentName() {
        return departmentName;
    }

    public void setDepartmentName(String departmentName) {
        this.departmentName = departmentName;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public List<Employee> getEmployees() {
        return employees;
    }

    public void setEmployees(List<Employee> employees) {
        this.employees = employees;
    }
}
```

### Explication des annotations :
- **`@ManyToOne`** dans l'entité `Employee` indique qu'un employé appartient à un département.
- **`@JoinColumn(name = "department_id")`** définit la clé étrangère `department_id` dans l'entité `Employee` qui fait référence à l'attribut `departmentId` dans l'entité `Department`.
- **`mappedBy = "department"`** dans `Department` indique que `employees` est la liste des employés qui appartiennent à ce département, et que la relation est définie par l'attribut `department` dans l'entité `Employee`.

### Utilisation dans les méthodes de repository pour les jointures :
- Lorsque vous réalisez une jointure, vous utiliserez le **nom de la relation** (`department`) dans les méthodes de votre repository JPA.

Exemple de jointure avec méthode JPA :
```java
List<Employee> findByDepartmentDepartmentName(String departmentName);
```
- Ici, `Department` est le nom de la relation (attribut `department` dans `Employee`).
- `DepartmentName` fait référence à l'attribut `departmentName` dans l'entité `Department`.

Cela permet à Spring Data JPA de générer automatiquement la requête SQL pour effectuer la jointure entre les entités `Employee` et `Department` via l'attribut `department`.



---

### Recommandations pour les jointures avancées :
- **Utilisation des annotations JPQL** : Pour des requêtes encore plus complexes, vous pouvez utiliser l'annotation `@Query` et écrire directement du JPQL ou SQL natif.
- **Optimisation** : Si vos jointures sont trop complexes, envisagez d'utiliser des vues ou de simplifier vos relations de données.

Grâce à ces conventions de nommage, vous pouvez éviter d'écrire manuellement des requêtes SQL tout en effectuant des jointures sophistiquées et en gardant un code lisible et maintenable.













### Liens ancrés ajoutés :

- [Annexe 1 - Méthodes personnalisées dans Spring Data JPA](#annexe-1---méthodes-personnalisées-dans-spring-data-jpa)
- [Exercice 1 - Application JPA avec Customer et Card](#exercice-1---application-jpa-avec-customer-et-card)
- [Exercice 2 - Diagramme de la base de données avec Airport, Flight et Passenger](#exercice-2---diagramme-de-la-base-de-données-avec-airport-flight-et-passenger)
- [Exercice 3 - Jointures dans Spring Data JPA](#exercice-3---jointures-dans-spring-data-jpa)





